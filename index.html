<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, interactive-widget=resizes-content">
<meta name="theme-color" content="#0a0a0a">
<title>Ты не случаен</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  width: 100%; height: 100dvh; overflow: hidden;
  background: #0a0a0a; color: #e0e0e0;
  font-family: 'JetBrains Mono', monospace;
  -webkit-tap-highlight-color: transparent;
  overscroll-behavior: none;
}
body { padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }

#app { width: 100%; height: 100%; position: relative; }

.screen {
  position: absolute; inset: 0;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  opacity: 0; pointer-events: none; transition: opacity 200ms ease;
}
.screen.active { opacity: 1; pointer-events: auto; }

/* ===== WELCOME ===== */
#welcome { padding: 2rem; text-align: center; gap: 2rem; }
#welcome h1 { font-size: 2.4rem; font-weight: 700; color: #fff; letter-spacing: -0.03em; line-height: 1.1; }
#welcome .subtitle { font-size: 1rem; color: #00ff88; font-weight: 700; }
#welcome .desc { font-size: 0.85rem; color: #888; line-height: 1.7; max-width: 320px; }
#welcome .desc strong { color: #e0e0e0; }

.btn-start {
  background: #00ff88; color: #0a0a0a; border: none;
  padding: 1.1rem 3.5rem; font-family: 'JetBrains Mono', monospace;
  font-size: 1.15rem; font-weight: 700; border-radius: 10px; cursor: pointer;
  animation: pulse-glow 2s ease-in-out infinite; transition: transform 100ms ease;
}
.btn-start:active { transform: scale(0.96); }

@keyframes pulse-glow {
  0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.3); }
  50% { box-shadow: 0 0 40px rgba(0, 255, 136, 0.6); }
}

/* ===== GAME ===== */
#game { user-select: none; touch-action: manipulation; cursor: pointer; }

.water-bg {
  position: absolute; bottom: 0; left: 0; right: 0; height: 100%;
  background: rgba(0, 255, 136, 0.15);
  transition: height 300ms ease-out, background-color 500ms ease;
  pointer-events: none; z-index: 0;
}
.game-divider {
  position: absolute; top: 0; bottom: 0; left: 50%; width: 1px;
  background: rgba(255,255,255,0.08); z-index: 1; pointer-events: none;
}
.zone-label {
  position: absolute; top: 50%; transform: translateY(-50%);
  font-size: 1.5rem; color: rgba(255,255,255,0.06); z-index: 1; pointer-events: none;
}
.zone-label.left { left: calc(25% - 0.5em); }
.zone-label.right { right: calc(25% - 0.5em); }

.game-hud {
  position: absolute; top: 0; left: 0; right: 0; z-index: 2; pointer-events: none;
  display: flex; flex-direction: column; align-items: center; padding-top: 3rem; gap: 0.25rem;
}
.hud-level { font-size: 0.7rem; color: #555; letter-spacing: 0.05em; }
.hud-balance { font-size: 2.5rem; font-weight: 700; color: #e0e0e0; }
.hud-prediction-result {
  font-size: 1.5rem; opacity: 0; transition: opacity 150ms ease;
  height: 2rem; display: flex; align-items: center; justify-content: center;
}
.hud-prediction-result.correct { color: #ff2244; }
.hud-prediction-result.wrong { color: #00ff88; }
.hud-prediction-result.show { opacity: 1; }

.hud-bottom {
  position: absolute; bottom: 1.5rem; left: 0; right: 0;
  text-align: center; z-index: 2; pointer-events: none;
  font-size: 1rem; font-weight: 700; color: #555;
}

.btn-stop {
  position: absolute; top: 1rem; right: 1rem; z-index: 3;
  background: transparent; border: 1px solid rgba(255,255,255,0.15);
  color: rgba(255,255,255,0.3); font-family: 'JetBrains Mono', monospace;
  font-size: 0.7rem; padding: 0.4rem 0.8rem; border-radius: 4px;
  cursor: pointer; transition: opacity 200ms;
}
.btn-stop:disabled { opacity: 0; pointer-events: none; }
.btn-stop:hover:not(:disabled) { color: rgba(255,255,255,0.6); border-color: rgba(255,255,255,0.3); }

.ripple {
  position: absolute; border-radius: 50%; background: rgba(255,255,255,0.15);
  transform: scale(0); animation: ripple-anim 400ms ease-out forwards;
  pointer-events: none; z-index: 1;
}
@keyframes ripple-anim { to { transform: scale(1); opacity: 0; } }

/* ===== RESULT ===== */
#result {
  padding: 2rem 1.5rem; text-align: center; overflow-y: auto;
  justify-content: flex-start; padding-top: 3rem; gap: 1rem;
}
#result h2 { font-size: 1.4rem; font-weight: 700; line-height: 1.3; }
.result-balance { font-size: 2.2rem; font-weight: 700; }

.result-stats { width: 100%; max-width: 340px; text-align: left; font-size: 0.8rem; color: #999; line-height: 1.8; }
.result-stats span { color: #e0e0e0; }

.balance-graph-container { width: 100%; max-width: 340px; }
.balance-graph-label { font-size: 0.7rem; color: #555; text-align: left; margin-bottom: 0.3rem; }
.balance-graph {
  width: 100%; height: 80px; border-radius: 6px; overflow: hidden;
  background: #111; border: 1px solid #222;
}

.pattern-map-container { width: 100%; max-width: 340px; display: flex; flex-direction: column; gap: 0.3rem; }
.pattern-map-label { font-size: 0.7rem; color: #555; text-align: left; }
.pattern-map { display: flex; flex-wrap: wrap; gap: 1px; }
.pattern-map .cell { width: 6px; height: 6px; border-radius: 1px; }

.result-buttons { display: flex; flex-direction: column; gap: 0.75rem; width: 100%; max-width: 280px; margin-top: 0.5rem; }

.btn-primary {
  background: #00ff88; color: #0a0a0a; border: none; padding: 0.9rem 2rem;
  font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 700;
  border-radius: 8px; cursor: pointer; transition: transform 100ms;
}
.btn-primary:active { transform: scale(0.96); }
.btn-secondary {
  background: transparent; color: #999; border: 1px solid #333; padding: 0.8rem 2rem;
  font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; border-radius: 8px;
  cursor: pointer; transition: transform 100ms;
}
.btn-secondary:active { transform: scale(0.96); }

/* ===== THEORY (single scroll) ===== */
#theory {
  padding: 1.5rem; padding-bottom: 3rem; overflow-y: auto;
  justify-content: flex-start; align-items: stretch; gap: 0;
}
.theory-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem; }
.theory-header h2 { font-size: 1.3rem; font-weight: 700; }
.btn-back {
  background: transparent; border: 1px solid #333; color: #999;
  font-family: 'JetBrains Mono', monospace; font-size: 0.75rem;
  padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer;
}

.theory-body { font-size: 0.88rem; line-height: 1.7; color: #ccc; }
.theory-body p { margin-bottom: 1rem; }
.theory-body strong { color: #e0e0e0; }
.theory-body a { color: #00ff88; text-decoration: none; border-bottom: 1px solid rgba(0,255,136,0.3); transition: border-color 150ms; }
.theory-body a:hover { border-color: #00ff88; }
.theory-body ul { padding-left: 1.2rem; margin-bottom: 1rem; }
.theory-body li { margin-bottom: 0.4rem; }

.theory-body .formula {
  background: #111; border: 1px solid #222; border-radius: 6px;
  padding: 0.8rem 1rem; margin: 0.8rem 0; font-size: 0.8rem; color: #aaa; overflow-x: auto;
}
.theory-body .example-box {
  background: #111; border-left: 3px solid #00ff88; padding: 0.8rem 1rem;
  margin: 0.8rem 0; font-size: 0.82rem; color: #bbb; line-height: 1.6;
}
.theory-body .example-box strong { color: #00ff88; }

.theory-divider {
  border: none; border-top: 1px solid #222; margin: 1.5rem 0;
}
.theory-section-title {
  font-size: 1rem; font-weight: 700; color: #e0e0e0; margin-bottom: 1rem;
}
.theory-play-btn { align-self: center; margin: 1.5rem 0; }

.author-link {
  margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #1a1a1a;
  text-align: center; font-size: 0.7rem; color: #444;
}
.author-link a { color: #555; text-decoration: none; border-bottom: 1px solid #333; }
.author-link a:hover { color: #888; }

/* ===== LEVEL BADGE ===== */
.level-badge {
  display: inline-block; padding: 0.2rem 0.6rem; border-radius: 4px;
  font-size: 0.7rem; font-weight: 700; letter-spacing: 0.05em;
}
.level-badge.l1 { border: 1px solid #00ff88; color: #00ff88; }
.level-badge.l2 { border: 1px solid #ffcc00; color: #ffcc00; }
.level-badge.l3 { border: 1px solid #ff2244; color: #ff2244; }

.result-level-up {
  background: rgba(0,255,136,0.08); border: 1px solid rgba(0,255,136,0.3);
  border-radius: 8px; padding: 1rem; text-align: center; width: 100%; max-width: 340px;
}
.result-level-up .level-up-title { font-size: 1rem; font-weight: 700; color: #00ff88; margin-bottom: 0.3rem; }
.result-level-up .level-up-desc { font-size: 0.75rem; color: #999; }

.btn-next-level {
  background: #ffcc00; color: #0a0a0a; border: none; padding: 0.9rem 2rem;
  font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 700;
  border-radius: 8px; cursor: pointer; transition: transform 100ms;
}
.btn-next-level:active { transform: scale(0.96); }
.btn-next-level.final { background: #ff2244; color: #fff; }

.fade-item { opacity: 0; transform: translateY(10px); animation: fade-up 300ms ease forwards; }
@keyframes fade-up { to { opacity: 1; transform: translateY(0); } }
</style>
</head>
<body>
<div id="app">

  <!-- WELCOME -->
  <div id="welcome" class="screen active">
    <h1>Ты не случаен</h1>
    <p class="subtitle">Попробуй обыграть алгоритм</p>
    <p class="desc">Нажимай на <strong>правую</strong> и <strong>левую</strong> половины экрана в случайном порядке. Алгоритм будет предсказывать каждое твоё следующее нажатие.<br><br>Угадал &mdash; ты теряешь <strong>$1</strong>.<br>Не угадал &mdash; ты получаешь <strong>$1.05</strong>.</p>
    <button class="btn-start" id="btnStart">Играть</button>
  </div>

  <!-- GAME -->
  <div id="game" class="screen">
    <div class="water-bg" id="waterBg"></div>
    <div class="game-divider"></div>
    <div class="zone-label left">0</div>
    <div class="zone-label right">1</div>
    <div class="game-hud">
      <div class="hud-level" id="hudLevel"></div>
      <div class="hud-balance" id="hudBalance">$50.00</div>
      <div class="hud-prediction-result" id="hudPredResult"></div>
    </div>
    <div class="hud-bottom" id="hudCounter">0/100</div>
    <button class="btn-stop" id="btnStop" disabled>Стоп</button>
  </div>

  <!-- RESULT -->
  <div id="result" class="screen"></div>

  <!-- THEORY -->
  <div id="theory" class="screen"></div>

</div>

<script>
'use strict';

// ===== LEVELS =====
const LEVELS = [
  { id: 1, name: 'Уровень 1', presses: 100,  balance: 10, reward: 1.05, label: 'УРОВЕНЬ 1', css: 'l1', stopMin: 20 },
  { id: 2, name: 'Уровень 2', presses: 200,  balance: 10, reward: 1.05, label: 'УРОВЕНЬ 2', css: 'l2', stopMin: 50 },
  { id: 3, name: 'Уровень 3', presses: 300,  balance: 10, reward: 1.00, label: 'УРОВЕНЬ 3', css: 'l3', stopMin: 80 },
];

// ===== STATE =====
const state = {
  screen: 'welcome',
  level: 0,
  maxUnlocked: 0,
  balance: 50.00,
  initialBalance: 50.00,
  balanceHistory: [],
  presses: [],
  predictions: [],
  correct: [],
  table: {},
  totalPresses: 0,
  correctPredictions: 0,
  gameOver: false,
  gameOverReason: '',
  lastPressTime: 0,
};

const MIN_INTERVAL = 100;
const WARMUP = 3;
const MAX_K = 5;

// ===== SCREENS =====
function showScreen(name) {
  state.screen = name;
  document.querySelectorAll('.screen').forEach(s => s.classList.toggle('active', s.id === name));
}

// ===== INIT TABLE =====
function initTable() {
  state.table = {};
  for (let k = 1; k <= MAX_K; k++) {
    for (let i = 0; i < (1 << k); i++) {
      state.table[i.toString(2).padStart(k, '0')] = { 0: 0, 1: 0 };
    }
  }
}

// ===== PREDICTION (ensemble) =====
function predict() {
  const n = state.presses.length;
  if (n < 1) return Math.random() < 0.5 ? 0 : 1;
  let score = 0;

  for (let k = 1; k <= MAX_K; k++) {
    if (n < k) continue;
    const entry = state.table[state.presses.slice(-k).join('')];
    if (!entry) continue;
    const total = entry[0] + entry[1];
    if (total === 0) continue;
    const p1 = (entry[1] + 1) / (total + 2);
    const p0 = (entry[0] + 1) / (total + 2);
    score += (p1 - p0) * Math.sqrt(total) * (1 + k * 0.5);
  }

  if (n >= 3) {
    const total1 = state.presses.reduce((a, b) => a + b, 0);
    score += ((total1 + 1) / (n + 2) - 0.5);
  }

  if (n >= 5) {
    let sw = 0;
    for (let i = 1; i < n; i++) if (state.presses[i] !== state.presses[i-1]) sw++;
    const alt = (sw / (n - 1) - 0.5) * 3;
    score += state.presses[n-1] === 1 ? -alt : alt;
  }

  if (n >= 6) {
    const w = Math.min(10, n);
    const recent = state.presses.slice(-w);
    let rsw = 0;
    for (let i = 1; i < recent.length; i++) if (recent[i] !== recent[i-1]) rsw++;
    const ralt = (rsw / (recent.length - 1) - 0.5) * 2;
    score += state.presses[n-1] === 1 ? -ralt : ralt;
  }

  if (score > 0) return 1;
  if (score < 0) return 0;
  return Math.random() < 0.5 ? 0 : 1;
}

function updateTable(actual) {
  const n = state.presses.length;
  for (let k = 1; k <= MAX_K; k++) {
    if (n < k + 1) continue;
    const ctx = state.presses.slice(-(k+1), -1).join('');
    if (state.table[ctx]) state.table[ctx][actual]++;
  }
}

// ===== WATER =====
function updateWater() {
  const ratio = Math.max(0, Math.min(1, state.balance / state.initialBalance));
  const el = document.getElementById('waterBg');
  el.style.height = (ratio * 100) + '%';
  el.style.background = 'hsla(' + (ratio * 150) + ', 80%, 50%, 0.15)';
}

// ===== HUD =====
function updateHUD() {
  const lvl = LEVELS[state.level];
  document.getElementById('hudLevel').innerHTML = '<span class="level-badge ' + lvl.css + '">' + lvl.label + '</span>';
  document.getElementById('hudBalance').textContent = '$' + state.balance.toFixed(2);
  document.getElementById('hudCounter').textContent = state.totalPresses + '/' + lvl.presses;
  document.getElementById('btnStop').disabled = state.totalPresses < lvl.stopMin;
}

function flashResult(wasCorrect) {
  const el = document.getElementById('hudPredResult');
  el.textContent = wasCorrect ? '\u2717' : '\u2713';
  el.className = 'hud-prediction-result show ' + (wasCorrect ? 'correct' : 'wrong');
  setTimeout(() => el.classList.remove('show'), 500);
}

// ===== RIPPLE & VIBRATE =====
function createRipple(x, y) {
  const r = document.createElement('div');
  r.className = 'ripple';
  r.style.cssText = 'width:80px;height:80px;left:' + (x-40) + 'px;top:' + (y-40) + 'px';
  document.getElementById('game').appendChild(r);
  setTimeout(() => r.remove(), 400);
}

// ===== GAME PRESS =====
let activePointerId = null;

function handlePress(choice, x, y, pointerId) {
  if (state.gameOver) return;
  // Block multitouch: only one finger at a time
  if (activePointerId !== null && activePointerId !== pointerId) return;
  const now = Date.now();
  if (now - state.lastPressTime < MIN_INTERVAL) return;
  state.lastPressTime = now;

  createRipple(x, y);
  if (navigator.vibrate) navigator.vibrate(10);

  const prediction = predict();
  state.presses.push(choice);
  state.totalPresses++;
  updateTable(choice);

  if (state.totalPresses > WARMUP) {
    const hit = prediction === choice;
    state.predictions.push(prediction);
    state.correct.push(hit);
    if (hit) { state.correctPredictions++; state.balance -= 1.00; }
    else { state.balance += LEVELS[state.level].reward; }
    state.balance = Math.round(state.balance * 100) / 100;
    state.balanceHistory.push(state.balance);
    flashResult(hit);
  }

  updateWater();
  updateHUD();

  const limit = LEVELS[state.level].presses;
  if (state.balance <= 0) {
    state.balance = 0; state.gameOver = true; state.gameOverReason = 'bankrupt';
    setTimeout(showResult, 400);
  } else if (state.totalPresses >= limit) {
    state.gameOver = true; state.gameOverReason = 'limit';
    setTimeout(showResult, 400);
  }
}

// ===== ANALYTICS =====
const SHEETS_URL = 'https://script.google.com/macros/s/AKfycbyUfEUxzWtkLG6-q4nEob-4ORS7OQTzkhQdHsX6dM9i1H5OA_NwVOKgjhKwNG2srpiz4A/exec';

function getSessionId() {
  let id = localStorage.getItem('tns_session');
  if (!id) {
    id = crypto.randomUUID ? crypto.randomUUID() :
      'xxxx-xxxx-xxxx'.replace(/x/g, () => (Math.random()*16|0).toString(16));
    localStorage.setItem('tns_session', id);
  }
  return id;
}

function sendStats(d) {
  if (SHEETS_URL === 'PLACEHOLDER') return;
  try { fetch(SHEETS_URL, { method:'POST', mode:'no-cors', headers:{'Content-Type':'application/json'}, body:JSON.stringify(d) }).catch(()=>{}); } catch(e){}
}

// ===== BALANCE GRAPH (canvas) =====
function drawBalanceGraph(canvas, history, initial) {
  const ctx = canvas.getContext('2d');
  const W = canvas.width = canvas.offsetWidth * 2;
  const H = canvas.height = canvas.offsetHeight * 2;
  ctx.scale(2, 2);
  const w = W / 2, h = H / 2;

  const all = [initial, ...history];
  const maxB = Math.max(...all, initial * 1.2);
  const minB = Math.min(...all, 0);
  const range = maxB - minB || 1;

  // Grid line at initial balance
  const yInit = h - ((initial - minB) / range) * (h - 8) - 4;
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 0.5;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(0, yInit);
  ctx.lineTo(w, yInit);
  ctx.stroke();
  ctx.setLineDash([]);

  // Line
  ctx.beginPath();
  ctx.strokeStyle = '#00ff88';
  ctx.lineWidth = 1.5;
  for (let i = 0; i < all.length; i++) {
    const x = (i / (all.length - 1)) * w;
    const y = h - ((all[i] - minB) / range) * (h - 8) - 4;
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  // Gradient fill
  const last = all[all.length - 1];
  const yEnd = h - ((last - minB) / range) * (h - 8) - 4;
  const grad = ctx.createLinearGradient(0, 0, 0, h);
  if (last >= initial) {
    grad.addColorStop(0, 'rgba(0,255,136,0.2)');
    grad.addColorStop(1, 'rgba(0,255,136,0)');
  } else {
    grad.addColorStop(0, 'rgba(255,34,68,0.15)');
    grad.addColorStop(1, 'rgba(255,34,68,0)');
    ctx.strokeStyle = '#ff2244';
    ctx.beginPath();
    for (let i = 0; i < all.length; i++) {
      const x = (i / (all.length - 1)) * w;
      const y = h - ((all[i] - minB) / range) * (h - 8) - 4;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
  }
  ctx.lineTo(w, h);
  ctx.lineTo(0, h);
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();
}

// ===== RESULT =====
function showResult() {
  const lvl = LEVELS[state.level];
  const scored = state.correct.length;
  const correctN = state.correctPredictions;
  const pct = scored > 0 ? (correctN / scored * 100) : 0;
  const won = state.balance >= state.initialBalance;
  const hasNext = state.level < LEVELS.length - 1;

  let title = '';
  if (state.gameOverReason === 'bankrupt') title = 'Алгоритм забрал всё';
  else if (won) title = 'Ты обыграл алгоритм!';
  else if (pct >= 70) title = 'Ты полностью предсказуем';
  else if (pct >= 60) title = 'Алгоритм читает тебя';
  else if (pct >= 55) title = 'Почти, но не случайно';
  else if (pct >= 50) title = 'Впечатляюще!';
  else title = 'Невероятно!';

  if (won && hasNext && state.level + 1 > state.maxUnlocked) state.maxUnlocked = state.level + 1;

  const count0 = state.presses.filter(p => p === 0).length;
  const count1 = state.presses.length - count0;

  const balColor = won ? '#00ff88' : '#ff2244';

  const cellSize = state.presses.length > 200 ? 4 : 6;
  const cs = ';width:' + cellSize + 'px;height:' + cellSize + 'px';

  let pressMap = '';
  state.presses.forEach(p => {
    pressMap += '<div class="cell" style="background:' + (p===0?'#333':'#aaa') + cs + '"></div>';
  });
  let predMap = '';
  const warmup = state.presses.length - state.correct.length;
  for (let i = 0; i < warmup; i++) predMap += '<div class="cell" style="background:#1a1a1a' + cs + '"></div>';
  state.correct.forEach(c => {
    predMap += '<div class="cell" style="background:' + (c?'#ff2244':'#00ff88') + cs + '"></div>';
  });

  let levelUpHTML = '';
  if (won && hasNext) {
    const nx = LEVELS[state.level + 1];
    const rewardDesc = nx.reward === 1.00 ? ', ставки $1/$1' : '';
    levelUpHTML = '<div class="result-level-up fade-item" style="animation-delay:350ms"><div class="level-up-title">Открыт ' + nx.name + '!</div><div class="level-up-desc">' + nx.presses + ' нажатий, $' + nx.balance + ' на старте' + rewardDesc + '</div></div>';
  } else if (won && !hasNext) {
    levelUpHTML = '<div class="result-level-up fade-item" style="animation-delay:350ms"><div class="level-up-title" style="color:#ff2244">Все уровни пройдены!</div><div class="level-up-desc">300 нажатий, ставки $1/$1, и ты выстоял.</div></div>';
  }

  let btns = '';
  if (won && hasNext) {
    const nx = LEVELS[state.level + 1];
    btns = '<button class="btn-next-level' + (nx.id===3?' final':'') + '" id="btnNextLevel">' + nx.name + ' &rarr;</button><button class="btn-secondary" id="btnRetry">Переиграть</button>';
  } else {
    btns = '<button class="btn-primary" id="btnRetry">Ещё раз</button>';
  }

  document.getElementById('result').innerHTML =
    '<span class="level-badge ' + lvl.css + ' fade-item" style="animation-delay:0ms">' + lvl.label + '</span>' +
    '<h2 class="fade-item" style="animation-delay:50ms">' + title + '</h2>' +
    '<div class="result-balance fade-item" style="animation-delay:100ms;color:' + balColor + '">$' + state.balance.toFixed(2) + '</div>' +
    '<div class="result-stats fade-item" style="animation-delay:150ms">' +
      'Угадано: <span>' + correctN + ' из ' + scored + ' (' + pct.toFixed(0) + '%)</span><br>' +
      'Лево/право: <span>' + count0 + '/' + count1 + '</span>' +
    '</div>' +
    '<div class="balance-graph-container fade-item" style="animation-delay:200ms">' +
      '<div class="balance-graph-label">Как менялся баланс</div>' +
      '<canvas class="balance-graph" id="balGraph"></canvas>' +
    '</div>' +
    '<div class="pattern-map-container fade-item" style="animation-delay:280ms">' +
      '<div class="pattern-map-label">Твои нажатия</div>' +
      '<div class="pattern-map">' + pressMap + '</div>' +
      '<div class="pattern-map-label" style="margin-top:0.4rem">Предсказания алгоритма</div>' +
      '<div class="pattern-map">' + predMap + '</div>' +
    '</div>' +
    levelUpHTML +
    '<div class="result-buttons fade-item" style="animation-delay:380ms">' + btns +
      '<button class="btn-secondary" id="btnTheory">Как это работает?</button>' +
    '</div>';

  document.getElementById('btnRetry').addEventListener('click', () => startGame(state.level));
  const nextBtn = document.getElementById('btnNextLevel');
  if (nextBtn) nextBtn.addEventListener('click', () => startGame(state.level + 1));
  document.getElementById('btnTheory').addEventListener('click', showTheory);

  showScreen('result');

  // Draw graph after screen is visible
  requestAnimationFrame(() => {
    const canvas = document.getElementById('balGraph');
    if (canvas && state.balanceHistory.length > 1) drawBalanceGraph(canvas, state.balanceHistory, state.initialBalance);
  });

  sendStats({
    sessionId: getSessionId(), level: lvl.id,
    totalPresses: state.totalPresses, correctPredictions: correctN,
    accuracy: +pct.toFixed(1), balance: state.balance, won: won,
    reason: state.gameOverReason, ratio01: count0+'/'+count1,
    maxRun: 0, topTrigram: '',
    sequence: state.presses.join(''), userAgent: navigator.userAgent,
  });
}

// ===== THEORY (single scroll page) =====
function showTheory() {
  document.getElementById('theory').innerHTML =
    '<div class="theory-header"><h2>Как это работает?</h2><button class="btn-back" id="btnBackResult">&larr; Назад</button></div>' +
    '<div class="theory-body" id="theoryBody">' +

    // === PART 1: Simple ===
    '<p><strong>Почему алгоритм угадывает?</strong></p>' +
    '<p>Люди не умеют быть случайными. Когда ты нажимаешь «лево-право-лево-право» &mdash; тебе кажется, что это случайно. Но настоящая случайность выглядит иначе: в ней регулярно бывает 4&ndash;5 одинаковых подряд, и это нормально.</p>' +
    '<p>Алгоритм запоминает, что ты делал после каждой комбинации последних нажатий. Например: <em>«после лево-право-лево этот человек 5 раз нажал право и 1 раз лево &mdash; ставлю на право»</em>. Таких комбинаций десятки, и по каждой алгоритм ведёт счёт.</p>' +
    '<div class="example-box"><strong>Почему первые 3 нажатия не считаются?</strong> Алгоритм только собирает данные &mdash; ему нужна хотя бы минимальная история, чтобы начать предсказывать. Это как разминка: он смотрит, но ещё не ставит.</div>' +
    '<p><strong>Экономика игры.</strong> На первых двух уровнях алгоритм платит $1.05 за каждый промах, а забирает $1 за каждое угадывание. Шансы слегка в твою пользу &mdash; но только если ты играешь случайно (50/50). Алгоритм угадывает больше 50%, и этого достаточно, чтобы ты проигрывал. На третьем уровне ставки равны: $1 против $1 &mdash; без всякой форы.</p>' +
    '<p>Идею этой демонстрации придумал <a href="https://en.wikipedia.org/wiki/Scott_Aaronson" target="_blank">Скотт Ааронсон</a>, профессор информатики, чтобы показать: человеческий мозг &mdash; плохой генератор случайных чисел.</p>' +

    '<div style="text-align:center"><button class="btn-primary theory-play-btn" id="btnPlay1">Играть снова</button></div>' +

    // === PART 2: Deeper ===
    '<hr class="theory-divider">' +
    '<p class="theory-section-title">Подробнее: модели и паттерны</p>' +

    '<p>Алгоритм использует не одну модель, а <strong>пять одновременно</strong> &mdash; разной глубины. Одна смотрит только на последнее нажатие, другая на два последних, и так далее до пяти.</p>' +
    '<p>Это как если бы пять друзей одновременно пытались угадать твой следующий ход: один помнит только предыдущий, другой &mdash; два, третий &mdash; три. Потом они голосуют, и побеждает мнение большинства.</p>' +

    '<p><strong>Что такое <a href="https://ru.wikipedia.org/wiki/Цепь_Маркова" target="_blank">марковская цепь</a>?</strong> Это математическая модель, в которой будущее зависит только от настоящего (и нескольких последних шагов), но не от всей истории. Такие модели описывают очень многое: от погоды до <a href="https://ru.wikipedia.org/wiki/PageRank" target="_blank">поисковых алгоритмов Google</a>.</p>' +

    '<p><strong>Три ловушки, в которые попадают люди:</strong></p>' +
    '<ul>' +
    '<li><strong><a href="https://en.wikipedia.org/wiki/Gambler%27s_fallacy" target="_blank">Заблуждение игрока</a></strong> &mdash; после нескольких «лево» кажется, что «пора бы нажать право». Настоящей монетке всё равно, что было до этого.</li>' +
    '<li><strong>Избегание серий</strong> &mdash; 4 одинаковых подряд кажутся «неслучайными». Но при 100 подбрасываниях монетки серия из 4+ выпадает почти наверняка.</li>' +
    '<li><strong>Подсознательные ритмы</strong> &mdash; лево-лево-право-право или лево-право-лево. Ты не замечаешь, но алгоритм видит сразу.</li>' +
    '</ul>' +

    '<p><strong>Почему на длинной дистанции сложнее?</strong> На 100 нажатиях алгоритм видел каждую комбинацию 1&ndash;3 раза &mdash; его предсказания неточные, и можно повезти. На 500 нажатиях у него 5&ndash;15 наблюдений на каждую комбинацию, и случайные совпадения выравниваются. Это <a href="https://ru.wikipedia.org/wiki/Закон_больших_чисел" target="_blank">закон больших чисел</a>.</p>' +

    '<p><strong>Связь с жизнью:</strong> точно такие же алгоритмы используются в сжатии данных (ZIP, GZIP). Если последовательность можно предсказать &mdash; её можно сжать. Твои нажатия «сжимаемы», а значит &mdash; предсказуемы.</p>' +

    // === PART 3: Hardcore ===
    '<hr class="theory-divider">' +
    '<p class="theory-section-title">Для тех, кто хочет математику</p>' +

    '<p><strong>Формализация.</strong> Алгоритм реализует <a href="https://en.wikipedia.org/wiki/Prediction_by_partial_matching" target="_blank">Prediction by Partial Matching</a> &mdash; ансамбль адаптивных марковских моделей порядков 1&hellip;5:</p>' +
    '<div class="formula">Для каждого порядка k от 1 до 5:<br>&nbsp;&nbsp;контекст s = (последние k нажатий)<br>&nbsp;&nbsp;счётчики C(s, 0) и C(s, 1)<br><br>Оценка вероятности (<a href="https://ru.wikipedia.org/wiki/Сглаживание_Лапласа" target="_blank">сглаживание Лапласа</a>):<br>&nbsp;&nbsp;P(1|s) = (C(s,1) + 1) / (C(s,0) + C(s,1) + 2)<br><br>Итоговый score = взвешенная сумма по всем k:<br>&nbsp;&nbsp;score += (P(1|s) &minus; P(0|s)) &middot; &radic;total &middot; (1 + k/2)</div>' +

    '<p>Сглаживание Лапласа &mdash; это байесовская оценка с равномерным приором Beta(1,1). Без него модель ломается на редких контекстах, где 0 наблюдений.</p>' +

    '<p><strong><a href="https://ru.wikipedia.org/wiki/Информационная_энтропия" target="_blank">Энтропия</a></strong> &mdash; мера непредсказуемости. Для идеально случайной последовательности энтропия максимальна: 1 бит на символ. Человеческая последовательность имеет энтропию около 0.7&ndash;0.9 бит/символ. Эта разница (0.1&ndash;0.3 бита) &mdash; именно то, что эксплуатирует алгоритм.</p>' +
    '<div class="formula">H = &minus;&Sigma; p(s,b) &middot; log&sub2; p(s,b)<br><br>Монетка: H = 1.0 бит/символ<br>Человек: H &asymp; 0.7&ndash;0.9 бит/символ<br>Дефицит &asymp; 0.1&ndash;0.3 бита = преимущество алгоритма</div>' +

    '<p><strong><a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv_complexity" target="_blank">Сложность Лемпеля&ndash;Зива</a></strong> &mdash; ещё один способ измерить случайность. Это количество «новых паттернов» в последовательности. У случайной строки оно растёт как n/log(n), у человеческой &mdash; значимо медленнее. Низкая LZ-сложность = последовательность сжимаема = предсказуема.</p>' +

    '<p><strong>Почему не нейросеть?</strong> При 100&ndash;500 наблюдениях и 62 контекстах данных слишком мало. Нейросеть <a href="https://ru.wikipedia.org/wiki/Переобучение" target="_blank">переобучится</a>. Частотный предиктор с байесовским сглаживанием &mdash; оптимален для задач с малой выборкой. Это тот редкий случай, когда простая модель лучше сложной.</p>' +

    '<p><strong>Связь с наукой:</strong> идея восходит к работам <a href="https://ru.wikipedia.org/wiki/Шеннон,_Клод" target="_blank">Клода Шеннона</a> 1950-х годов. Он просил людей предсказывать следующую букву в тексте и так измерял энтропию английского языка. Оказалось, что язык очень предсказуем (~1 бит/букву). Твои нажатия &mdash; тоже.</p>' +

    '<div style="text-align:center"><button class="btn-primary theory-play-btn" id="btnPlay2">Играть снова</button></div>' +

    '<div class="author-link">Демонстрация: <a href="https://www.facebook.com/teo.spiro.2025" target="_blank">Teo Spiro</a></div>' +
    '</div>';

  document.getElementById('btnBackResult').addEventListener('click', () => showScreen('result'));
  document.getElementById('btnPlay1').addEventListener('click', () => startGame(state.level));
  document.getElementById('btnPlay2').addEventListener('click', () => startGame(state.level));

  showScreen('theory');
}

// ===== START GAME =====
function startGame(levelIndex) {
  state.level = levelIndex || 0;
  const lvl = LEVELS[state.level];
  state.balance = lvl.balance;
  state.initialBalance = lvl.balance;
  state.balanceHistory = [lvl.balance];
  state.presses = [];
  state.predictions = [];
  state.correct = [];
  state.totalPresses = 0;
  state.correctPredictions = 0;
  state.gameOver = false;
  state.gameOverReason = '';
  state.lastPressTime = 0;
  initTable();
  updateWater();
  updateHUD();
  document.getElementById('hudPredResult').className = 'hud-prediction-result';
  document.getElementById('hudPredResult').textContent = '';
  showScreen('game');
}

// ===== EVENTS =====
document.getElementById('btnStart').addEventListener('click', () => startGame(0));

document.getElementById('game').addEventListener('pointerdown', (e) => {
  if (state.screen !== 'game' || state.gameOver) return;
  if (e.target.closest('.btn-stop')) return;
  activePointerId = e.pointerId;
  const rect = document.getElementById('game').getBoundingClientRect();
  handlePress(e.clientX < window.innerWidth / 2 ? 0 : 1, e.clientX - rect.left, e.clientY - rect.top, e.pointerId);
});

document.getElementById('game').addEventListener('pointerup', (e) => {
  if (e.pointerId === activePointerId) activePointerId = null;
});
document.getElementById('game').addEventListener('pointercancel', (e) => {
  if (e.pointerId === activePointerId) activePointerId = null;
});

document.getElementById('btnStop').addEventListener('click', () => {
  const lvl = LEVELS[state.level];
  if (state.totalPresses >= lvl.stopMin && !state.gameOver) {
    state.gameOver = true; state.gameOverReason = 'manual'; showResult();
  }
});

try { if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); } catch(e){}
</script>
</body>
</html>
