<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, interactive-widget=resizes-content">
<meta name="theme-color" content="#0a0a0a">
<title>–¢—ã –Ω–µ —Å–ª—É—á–∞–µ–Ω</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body {
  width: 100%;
  height: 100dvh;
  overflow: hidden;
  background: #0a0a0a;
  color: #e0e0e0;
  font-family: 'JetBrains Mono', monospace;
  -webkit-tap-highlight-color: transparent;
  overscroll-behavior: none;
}

body {
  padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
}

#app {
  width: 100%;
  height: 100%;
  position: relative;
}

.screen {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  opacity: 0;
  pointer-events: none;
  transition: opacity 200ms ease;
}

.screen.active {
  opacity: 1;
  pointer-events: auto;
}

/* ===== WELCOME SCREEN ===== */
#welcome {
  padding: 2rem;
  text-align: center;
  gap: 1.5rem;
}

#welcome h1 {
  font-size: 2rem;
  font-weight: 700;
  color: #e0e0e0;
  letter-spacing: -0.02em;
}

#welcome .desc {
  font-size: 0.875rem;
  color: #999;
  line-height: 1.6;
  max-width: 320px;
}

.hint-zones {
  display: flex;
  gap: 3rem;
  font-size: 1.25rem;
  color: #555;
}

.hint-zones span {
  opacity: 0.6;
}

.btn-start {
  background: #00ff88;
  color: #0a0a0a;
  border: none;
  padding: 1rem 3rem;
  font-family: 'JetBrains Mono', monospace;
  font-size: 1.1rem;
  font-weight: 700;
  border-radius: 8px;
  cursor: pointer;
  animation: pulse-glow 2s ease-in-out infinite;
  transition: transform 100ms ease;
}

.btn-start:active {
  transform: scale(0.96);
}

@keyframes pulse-glow {
  0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.3); }
  50% { box-shadow: 0 0 40px rgba(0, 255, 136, 0.6); }
}

/* ===== GAME SCREEN ===== */
#game {
  user-select: none;
  touch-action: manipulation;
  cursor: pointer;
}

.water-bg {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 100%;
  background: rgba(0, 255, 136, 0.15);
  transition: height 300ms ease-out, background-color 500ms ease;
  pointer-events: none;
  z-index: 0;
}

.game-divider {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 50%;
  width: 1px;
  background: rgba(255, 255, 255, 0.08);
  z-index: 1;
  pointer-events: none;
}

.zone-label {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  font-size: 1.5rem;
  color: rgba(255, 255, 255, 0.06);
  z-index: 1;
  pointer-events: none;
}

.zone-label.left {
  left: calc(25% - 0.5em);
}

.zone-label.right {
  right: calc(25% - 0.5em);
}

.game-hud {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  z-index: 2;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding-top: 3rem;
  gap: 0.25rem;
}

.hud-balance {
  font-size: 2.5rem;
  font-weight: 700;
  color: #e0e0e0;
}

.hud-accuracy {
  font-size: 0.875rem;
  color: #999;
}

.hud-prediction-result {
  font-size: 1.5rem;
  opacity: 0;
  transition: opacity 150ms ease;
  height: 2rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

.hud-prediction-result.correct {
  color: #ff2244;
}

.hud-prediction-result.wrong {
  color: #00ff88;
}

.hud-prediction-result.show {
  opacity: 1;
}

.hud-bottom {
  position: absolute;
  bottom: 1.5rem;
  left: 0;
  right: 0;
  text-align: center;
  z-index: 2;
  pointer-events: none;
  font-size: 0.75rem;
  color: #555;
}

.btn-stop {
  position: absolute;
  top: 1rem;
  right: 1rem;
  z-index: 3;
  background: transparent;
  border: 1px solid rgba(255, 255, 255, 0.15);
  color: rgba(255, 255, 255, 0.3);
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.7rem;
  padding: 0.4rem 0.8rem;
  border-radius: 4px;
  cursor: pointer;
  transition: opacity 200ms;
}

.btn-stop:disabled {
  opacity: 0;
  pointer-events: none;
}

.btn-stop:hover:not(:disabled) {
  color: rgba(255, 255, 255, 0.6);
  border-color: rgba(255, 255, 255, 0.3);
}

.ripple {
  position: absolute;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.15);
  transform: scale(0);
  animation: ripple-anim 400ms ease-out forwards;
  pointer-events: none;
  z-index: 1;
}

@keyframes ripple-anim {
  to {
    transform: scale(1);
    opacity: 0;
  }
}

/* ===== RESULT SCREEN ===== */
#result {
  padding: 2rem 1.5rem;
  text-align: center;
  overflow-y: auto;
  justify-content: flex-start;
  padding-top: 3rem;
  gap: 1rem;
}

#result h2 {
  font-size: 1.4rem;
  font-weight: 700;
  line-height: 1.3;
}

.result-balance {
  font-size: 2.2rem;
  font-weight: 700;
}

.result-stats {
  width: 100%;
  max-width: 340px;
  text-align: left;
  font-size: 0.8rem;
  color: #999;
  line-height: 1.8;
}

.result-stats span {
  color: #e0e0e0;
}

.pattern-map-container {
  width: 100%;
  max-width: 340px;
  display: flex;
  flex-direction: column;
  gap: 0.3rem;
}

.pattern-map-label {
  font-size: 0.7rem;
  color: #555;
  text-align: left;
}

.pattern-map {
  display: flex;
  flex-wrap: wrap;
  gap: 1px;
}

.pattern-map .cell {
  width: 6px;
  height: 6px;
  border-radius: 1px;
}

.result-buttons {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  width: 100%;
  max-width: 280px;
  margin-top: 0.5rem;
}

.btn-primary {
  background: #00ff88;
  color: #0a0a0a;
  border: none;
  padding: 0.9rem 2rem;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.9rem;
  font-weight: 700;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 100ms;
}

.btn-primary:active {
  transform: scale(0.96);
}

.btn-secondary {
  background: transparent;
  color: #999;
  border: 1px solid #333;
  padding: 0.8rem 2rem;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.85rem;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 100ms;
}

.btn-secondary:active {
  transform: scale(0.96);
}

/* ===== THEORY SCREEN ===== */
#theory {
  padding: 1.5rem;
  overflow-y: auto;
  justify-content: flex-start;
  align-items: stretch;
  gap: 0;
}

.theory-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.theory-header h2 {
  font-size: 1.2rem;
  font-weight: 700;
}

.btn-back {
  background: transparent;
  border: 1px solid #333;
  color: #999;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.75rem;
  padding: 0.4rem 0.8rem;
  border-radius: 4px;
  cursor: pointer;
}

.theory-tabs {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1.5rem;
}

.theory-tab {
  flex: 1;
  background: transparent;
  border: 1px solid #333;
  color: #777;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.7rem;
  padding: 0.6rem 0.3rem;
  border-radius: 6px;
  cursor: pointer;
  transition: all 150ms;
  text-align: center;
  line-height: 1.3;
}

.theory-tab.active {
  border-color: #00ff88;
  color: #00ff88;
  background: rgba(0, 255, 136, 0.05);
}

.theory-content {
  font-size: 0.9rem;
  line-height: 1.6;
  color: #ccc;
}

.theory-content p {
  margin-bottom: 1rem;
}

.theory-content strong {
  color: #e0e0e0;
}

.theory-content .formula {
  background: #111;
  border: 1px solid #222;
  border-radius: 6px;
  padding: 0.8rem 1rem;
  margin: 0.8rem 0;
  font-size: 0.8rem;
  color: #aaa;
  overflow-x: auto;
}

.theory-content ul {
  padding-left: 1.2rem;
  margin-bottom: 1rem;
}

.theory-content li {
  margin-bottom: 0.4rem;
}

.theory-content a {
  color: #00ff88;
  text-decoration: none;
  border-bottom: 1px solid rgba(0, 255, 136, 0.3);
  transition: border-color 150ms;
}

.theory-content a:hover {
  border-color: #00ff88;
}

.theory-content .example-box {
  background: #111;
  border-left: 3px solid #00ff88;
  padding: 0.8rem 1rem;
  margin: 0.8rem 0;
  font-size: 0.8rem;
  color: #bbb;
  line-height: 1.6;
}

.theory-content .example-box strong {
  color: #00ff88;
}

.theory-play-again {
  margin-top: 1.5rem;
  align-self: center;
}

/* ===== LEVEL BADGE ===== */
.hud-level {
  font-size: 0.7rem;
  color: #555;
  letter-spacing: 0.05em;
}

.level-badge {
  display: inline-block;
  padding: 0.2rem 0.6rem;
  border-radius: 4px;
  font-size: 0.7rem;
  font-weight: 700;
  letter-spacing: 0.05em;
}

.level-badge.l1 {
  border: 1px solid #00ff88;
  color: #00ff88;
}

.level-badge.l2 {
  border: 1px solid #ffcc00;
  color: #ffcc00;
}

.level-badge.l3 {
  border: 1px solid #ff2244;
  color: #ff2244;
}

.result-level-up {
  background: rgba(0, 255, 136, 0.08);
  border: 1px solid rgba(0, 255, 136, 0.3);
  border-radius: 8px;
  padding: 1rem;
  text-align: center;
  width: 100%;
  max-width: 340px;
}

.result-level-up .level-up-title {
  font-size: 1rem;
  font-weight: 700;
  color: #00ff88;
  margin-bottom: 0.3rem;
}

.result-level-up .level-up-desc {
  font-size: 0.75rem;
  color: #999;
}

.btn-next-level {
  background: #ffcc00;
  color: #0a0a0a;
  border: none;
  padding: 0.9rem 2rem;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.9rem;
  font-weight: 700;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 100ms;
}

.btn-next-level:active {
  transform: scale(0.96);
}

.btn-next-level.final {
  background: #ff2244;
  color: #fff;
}

/* Staggered result fade-in */
.fade-item {
  opacity: 0;
  transform: translateY(10px);
  animation: fade-up 300ms ease forwards;
}

@keyframes fade-up {
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
</style>
</head>
<body>
<div id="app">

  <!-- WELCOME -->
  <div id="welcome" class="screen active">
    <h1>–¢—ã –Ω–µ —Å–ª—É—á–∞–µ–Ω</h1>
    <p class="desc">–ü–æ–ø—Ä–æ–±—É–π –æ–±–º–∞–Ω—É—Ç—å –∞–ª–≥–æ—Ä–∏—Ç–º. –ù–∞–∂–∏–º–∞–π –Ω–∞ –ª–µ–≤—É—é –∏–ª–∏ –ø—Ä–∞–≤—É—é –ø–æ–ª–æ–≤–∏–Ω—É —ç–∫—Ä–∞–Ω–∞ –∫–∞–∫ –º–æ–∂–Ω–æ —Å–ª—É—á–∞–π–Ω–µ–µ. –ê–ª–≥–æ—Ä–∏—Ç–º –±—É–¥–µ—Ç –ø—Ä–µ–¥—Å–∫–∞–∑—ã–≤–∞—Ç—å –∫–∞–∂–¥–æ–µ —Ç–≤–æ—ë —Å–ª–µ–¥—É—é—â–µ–µ –Ω–∞–∂–∞—Ç–∏–µ. –ö–∞–∂–¥–æ–µ –≤–µ—Ä–Ω–æ–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ ‚Äî –º–∏–Ω—É—Å –¥–æ–ª–ª–∞—Ä –∏–∑ —Ç–≤–æ–µ–≥–æ –∫–æ—à–µ–ª—å–∫–∞.</p>
    <div class="hint-zones">
      <span>‚Üê0</span>
      <span>1‚Üí</span>
    </div>
    <button class="btn-start" id="btnStart">–ù–∞—á–∞—Ç—å</button>
  </div>

  <!-- GAME -->
  <div id="game" class="screen">
    <div class="water-bg" id="waterBg"></div>
    <div class="game-divider"></div>
    <div class="zone-label left">0</div>
    <div class="zone-label right">1</div>
    <div class="game-hud">
      <div class="hud-level" id="hudLevel"></div>
      <div class="hud-balance" id="hudBalance">$50.00</div>
      <div class="hud-accuracy" id="hudAccuracy">–ê–ª–≥–æ—Ä–∏—Ç–º: ‚Äî</div>
      <div class="hud-prediction-result" id="hudPredResult"></div>
    </div>
    <div class="hud-bottom" id="hudPresses">–ù–∞–∂–∞—Ç–∏–π: 0</div>
    <button class="btn-stop" id="btnStop" disabled>–°—Ç–æ–ø</button>
  </div>

  <!-- RESULT -->
  <div id="result" class="screen"></div>

  <!-- THEORY -->
  <div id="theory" class="screen"></div>

</div>

<script>
'use strict';

// ===== LEVELS =====
const LEVELS = [
  { id: 1, name: '–£—Ä–æ–≤–µ–Ω—å 1', presses: 100,  balance: 50,  label: '–£–†–û–í–ï–ù–¨ 1', css: 'l1', stopMin: 20 },
  { id: 2, name: '–£—Ä–æ–≤–µ–Ω—å 2', presses: 200,  balance: 100, label: '–£–†–û–í–ï–ù–¨ 2', css: 'l2', stopMin: 50 },
  { id: 3, name: '–£—Ä–æ–≤–µ–Ω—å 3', presses: 500,  balance: 200, label: '–£–†–û–í–ï–ù–¨ 3', css: 'l3', stopMin: 100 },
];

// ===== STATE =====
const state = {
  screen: 'welcome',
  level: 0,            // index into LEVELS
  maxUnlocked: 0,      // highest unlocked level index
  balance: 50.00,
  initialBalance: 50.00,
  presses: [],
  predictions: [],
  correct: [],
  table: {},
  totalPresses: 0,
  correctPredictions: 0,
  gameOver: false,
  gameOverReason: '',
  lastPressTime: 0,
};

const MIN_INTERVAL = 100;
const WARMUP = 3;
const MAX_K = 5;

// ===== SCREEN MANAGEMENT =====
function showScreen(name) {
  state.screen = name;
  document.querySelectorAll('.screen').forEach(s => {
    s.classList.toggle('active', s.id === name);
  });
}

// ===== INIT TABLE =====
// Tables for orders 1..MAX_K
function initTable() {
  state.table = {};
  for (let k = 1; k <= MAX_K; k++) {
    for (let i = 0; i < (1 << k); i++) {
      const key = i.toString(2).padStart(k, '0');
      state.table[key] = { 0: 0, 1: 0 };
    }
  }
}

// ===== PREDICTION =====
// Ensemble: combine predictions from all available context lengths (1..MAX_K)
// Each model votes with a weight proportional to its confidence and context length.
// Also blends in a global bias signal and an alternation bias signal.
function predict() {
  const n = state.presses.length;
  if (n < 1) return Math.random() < 0.5 ? 0 : 1;

  let score = 0; // positive = predict 1, negative = predict 0

  // --- Signal 1: Markov models of order 1..MAX_K (weighted ensemble) ---
  for (let k = 1; k <= MAX_K; k++) {
    if (n < k) continue;
    const ctx = state.presses.slice(-k).join('');
    const entry = state.table[ctx];
    if (!entry) continue;
    const total = entry[0] + entry[1];
    if (total === 0) continue;
    // Bayesian estimate with Laplace smoothing
    const p1 = (entry[1] + 1) / (total + 2);
    const p0 = (entry[0] + 1) / (total + 2);
    // Confidence: how far from 0.5, scaled by observations & context length
    const confidence = (p1 - p0) * Math.sqrt(total) * (1 + k * 0.5);
    score += confidence;
  }

  // --- Signal 2: Global bias (overall tendency toward 0 or 1) ---
  if (n >= 3) {
    const total0 = state.presses.filter(p => p === 0).length;
    const total1 = n - total0;
    const globalP1 = (total1 + 1) / (n + 2);
    const globalBias = (globalP1 - 0.5) * 2;
    score += globalBias * 0.5;
  }

  // --- Signal 3: Alternation bias (tendency to switch after current value) ---
  if (n >= 5) {
    let switches = 0;
    for (let i = 1; i < n; i++) {
      if (state.presses[i] !== state.presses[i - 1]) switches++;
    }
    const switchRate = switches / (n - 1);
    // If switchRate > 0.5, player tends to alternate -> predict opposite of last
    // If switchRate < 0.5, player tends to repeat -> predict same as last
    const last = state.presses[n - 1];
    const altSignal = (switchRate - 0.5) * 3;
    // If alternation-biased, nudge toward opposite of last press
    score += last === 1 ? -altSignal : altSignal;
  }

  // --- Signal 4: Recent momentum (last 10 presses pattern) ---
  if (n >= 6) {
    const window = Math.min(10, n);
    const recent = state.presses.slice(-window);
    let recentSwitches = 0;
    for (let i = 1; i < recent.length; i++) {
      if (recent[i] !== recent[i - 1]) recentSwitches++;
    }
    const recentSwitchRate = recentSwitches / (recent.length - 1);
    const last = state.presses[n - 1];
    const recentAlt = (recentSwitchRate - 0.5) * 2;
    score += last === 1 ? -recentAlt : recentAlt;
  }

  if (score > 0) return 1;
  if (score < 0) return 0;
  return Math.random() < 0.5 ? 0 : 1;
}

function updateTable(actual) {
  const n = state.presses.length;
  // Update all Markov tables of order 1..MAX_K
  for (let k = 1; k <= MAX_K; k++) {
    if (n < k + 1) continue;
    const ctx = state.presses.slice(-(k + 1), -1).join('');
    if (state.table[ctx]) {
      state.table[ctx][actual]++;
    }
  }
}

// ===== WATER LEVEL & COLOR =====
function updateWater() {
  const ratio = Math.max(0, Math.min(1, state.balance / state.initialBalance));
  const waterEl = document.getElementById('waterBg');
  waterEl.style.height = (ratio * 100) + '%';

  // Hue: 150 (green) -> 60 (yellow) -> 0 (red)
  const hue = ratio * 150;
  waterEl.style.background = `hsla(${hue}, 80%, 50%, 0.15)`;
}

// ===== HUD =====
function updateHUD() {
  const lvl = LEVELS[state.level];
  document.getElementById('hudLevel').innerHTML =
    '<span class="level-badge ' + lvl.css + '">' + lvl.label + '</span>';
  document.getElementById('hudBalance').textContent = '$' + state.balance.toFixed(2);

  const scored = state.correct.length;
  if (scored > 0) {
    const pct = ((state.correctPredictions / scored) * 100).toFixed(0);
    document.getElementById('hudAccuracy').textContent = `–ê–ª–≥–æ—Ä–∏—Ç–º: ${pct}%`;
  }

  document.getElementById('hudPresses').textContent = `–ù–∞–∂–∞—Ç–∏–π: ${state.totalPresses} / ${lvl.presses}`;

  const stopBtn = document.getElementById('btnStop');
  stopBtn.disabled = state.totalPresses < lvl.stopMin;
}

function flashPredictionResult(wasCorrect) {
  const el = document.getElementById('hudPredResult');
  el.textContent = wasCorrect ? '‚úó' : '‚úì';
  el.className = 'hud-prediction-result show ' + (wasCorrect ? 'correct' : 'wrong');
  setTimeout(() => el.classList.remove('show'), 500);
}

// ===== RIPPLE =====
function createRipple(x, y) {
  const ripple = document.createElement('div');
  ripple.className = 'ripple';
  const size = 80;
  ripple.style.width = size + 'px';
  ripple.style.height = size + 'px';
  ripple.style.left = (x - size / 2) + 'px';
  ripple.style.top = (y - size / 2) + 'px';
  document.getElementById('game').appendChild(ripple);
  setTimeout(() => ripple.remove(), 400);
}

// ===== VIBRATE =====
function vibrate() {
  if (navigator.vibrate) navigator.vibrate(10);
}

// ===== GAME PRESS =====
function handlePress(choice, x, y) {
  if (state.gameOver) return;

  const now = Date.now();
  if (now - state.lastPressTime < MIN_INTERVAL) return;
  state.lastPressTime = now;

  createRipple(x, y);
  vibrate();

  // Predict before recording
  const prediction = predict();

  // Record
  state.presses.push(choice);
  state.totalPresses++;

  // Update table with the new press
  updateTable(choice);

  // Score (only after warmup)
  if (state.totalPresses > WARMUP) {
    const wasCorrect = prediction === choice;
    state.predictions.push(prediction);
    state.correct.push(wasCorrect);

    if (wasCorrect) {
      state.correctPredictions++;
      state.balance -= 1.00;
    } else {
      state.balance += 1.05;
    }

    state.balance = Math.round(state.balance * 100) / 100;
    flashPredictionResult(wasCorrect);
  }

  updateWater();
  updateHUD();

  // Check end conditions
  const pressLimit = LEVELS[state.level].presses;
  if (state.balance <= 0) {
    state.balance = 0;
    state.gameOver = true;
    state.gameOverReason = 'bankrupt';
    setTimeout(() => showResult(), 400);
  } else if (state.totalPresses >= pressLimit) {
    state.gameOver = true;
    state.gameOverReason = 'limit';
    setTimeout(() => showResult(), 400);
  }
}

// ===== ANALYTICS =====
const SHEETS_URL = 'https://script.google.com/macros/s/AKfycbyUfEUxzWtkLG6-q4nEob-4ORS7OQTzkhQdHsX6dM9i1H5OA_NwVOKgjhKwNG2srpiz4A/exec';

// Persistent session ID (survives page reload, unique per browser)
function getSessionId() {
  let id = localStorage.getItem('tns_session');
  if (!id) {
    id = crypto.randomUUID ? crypto.randomUUID() :
      'xxxx-xxxx-xxxx'.replace(/x/g, () => (Math.random() * 16 | 0).toString(16));
    localStorage.setItem('tns_session', id);
  }
  return id;
}

function sendStats(statsData) {
  if (SHEETS_URL === 'PLACEHOLDER') return; // Not configured yet
  try {
    fetch(SHEETS_URL, {
      method: 'POST',
      mode: 'no-cors',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(statsData),
    }).catch(() => {}); // Silent fail ‚Äî don't interrupt the game
  } catch(e) {}
}

// ===== RESULT =====
function showResult() {
  const lvl = LEVELS[state.level];
  const scored = state.correct.length;
  const correctN = state.correctPredictions;
  const pct = scored > 0 ? (correctN / scored * 100) : 0;

  // Did the player win? (kept balance >= initial)
  const won = state.balance >= state.initialBalance;
  const hasNextLevel = state.level < LEVELS.length - 1;

  let title = '';
  if (state.gameOverReason === 'bankrupt') {
    title = '–ê–ª–≥–æ—Ä–∏—Ç–º –∑–∞–±—Ä–∞–ª –≤—Å–µ –¥–µ–Ω—å–≥–∏';
  } else if (won) {
    title = '–¢—ã –ø–µ—Ä–µ–∏–≥—Ä–∞–ª –∞–ª–≥–æ—Ä–∏—Ç–º!';
  } else if (pct >= 70) {
    title = '–¢—ã –∞–±—Å–æ–ª—é—Ç–Ω–æ –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º';
  } else if (pct >= 60) {
    title = '–ê–ª–≥–æ—Ä–∏—Ç–º —á–∏—Ç–∞–µ—Ç —Ç–µ–±—è –∫–∞–∫ –∫–Ω–∏–≥—É';
  } else if (pct >= 55) {
    title = '–ù–µ–ø–ª–æ—Ö–æ, –Ω–æ –Ω–µ —Å–ª—É—á–∞–π–Ω–æ';
  } else if (pct >= 50) {
    title = '–í–ø–µ—á–∞—Ç–ª—è—é—â–µ! –ü–æ—á—Ç–∏ —Å–ª—É—á–∞–π–Ω—ã–π';
  } else {
    title = '–ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ!';
  }

  // Unlock next level
  if (won && hasNextLevel && state.level + 1 > state.maxUnlocked) {
    state.maxUnlocked = state.level + 1;
  }

  // Stats
  const count0 = state.presses.filter(p => p === 0).length;
  const count1 = state.presses.filter(p => p === 1).length;

  let maxRun = 0, curRun = 1;
  for (let i = 1; i < state.presses.length; i++) {
    if (state.presses[i] === state.presses[i - 1]) {
      curRun++;
      if (curRun > maxRun) maxRun = curRun;
    } else {
      curRun = 1;
    }
  }
  if (state.presses.length > 0 && maxRun === 0) maxRun = 1;

  // Most frequent 3-gram
  const trigramCounts = {};
  for (let i = 0; i <= state.presses.length - 3; i++) {
    const tri = state.presses.slice(i, i + 3).join('');
    trigramCounts[tri] = (trigramCounts[tri] || 0) + 1;
  }
  let topTrigram = '‚Äî';
  let topTriCount = 0;
  for (const [tri, c] of Object.entries(trigramCounts)) {
    if (c > topTriCount) { topTriCount = c; topTrigram = tri; }
  }

  const balColor = state.balance >= state.initialBalance ? '#00ff88' : '#ff2244';

  // Pattern map ‚Äî limit cell size for level 3 (500 presses)
  const cellSize = state.presses.length > 200 ? 4 : 6;
  const cellStyle = ';width:' + cellSize + 'px;height:' + cellSize + 'px';

  let pressMap = '';
  state.presses.forEach(p => {
    const bg = p === 0 ? '#333' : '#aaa';
    pressMap += '<div class="cell" style="background:' + bg + cellStyle + '"></div>';
  });

  // Pad prediction row with empty cells for warmup period so rows are same length
  let predMap = '';
  const warmupCount = state.presses.length - state.correct.length;
  for (let i = 0; i < warmupCount; i++) {
    predMap += '<div class="cell" style="background:#1a1a1a' + cellStyle + '"></div>';
  }
  state.correct.forEach(c => {
    const bg = c ? '#ff2244' : '#00ff88';
    predMap += '<div class="cell" style="background:' + bg + cellStyle + '"></div>';
  });

  // Level-up block
  let levelUpHTML = '';
  if (won && hasNextLevel) {
    const next = LEVELS[state.level + 1];
    levelUpHTML = `
      <div class="result-level-up fade-item" style="animation-delay:350ms">
        <div class="level-up-title">–û—Ç–∫—Ä—ã—Ç ${next.name}!</div>
        <div class="level-up-desc">${next.presses} –Ω–∞–∂–∞—Ç–∏–π, $${next.balance} –Ω–∞ —Å—Ç–∞—Ä—Ç–µ. –£–¥–µ—Ä–∂–∏—à—å?</div>
      </div>
    `;
  } else if (won && !hasNextLevel) {
    levelUpHTML = `
      <div class="result-level-up fade-item" style="animation-delay:350ms">
        <div class="level-up-title" style="color:#ff2244">–í—Å–µ —É—Ä–æ–≤–Ω–∏ –ø—Ä–æ–π–¥–µ–Ω—ã!</div>
        <div class="level-up-desc">–¢—ã –ø—Ä–æ—à—ë–ª 500 –Ω–∞–∂–∞—Ç–∏–π –∏ –Ω–µ –ø—Ä–æ–∏–≥—Ä–∞–ª. –ù–µ–≤–µ—Ä–æ—è—Ç–Ω–æ.</div>
      </div>
    `;
  }

  // Buttons
  let buttonsHTML = '';
  if (won && hasNextLevel) {
    const next = LEVELS[state.level + 1];
    const btnClass = next.id === 3 ? 'btn-next-level final' : 'btn-next-level';
    buttonsHTML = `
      <button class="${btnClass}" id="btnNextLevel">${next.name} &rarr;</button>
      <button class="btn-secondary" id="btnRetry">–ü–µ—Ä–µ–∏–≥—Ä–∞—Ç—å —ç—Ç–æ—Ç —É—Ä–æ–≤–µ–Ω—å</button>
    `;
  } else {
    buttonsHTML = `
      <button class="btn-primary" id="btnRetry">–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â—ë —Ä–∞–∑</button>
    `;
  }

  const resultEl = document.getElementById('result');
  resultEl.innerHTML = `
    <span class="level-badge ${lvl.css} fade-item" style="animation-delay:0ms">${lvl.label}</span>
    <h2 class="fade-item" style="animation-delay:50ms">${title}</h2>
    <div class="result-balance fade-item" style="animation-delay:100ms;color:${balColor}">$${state.balance.toFixed(2)}</div>
    <div class="result-stats fade-item" style="animation-delay:200ms">
      –í—Å–µ–≥–æ –Ω–∞–∂–∞—Ç–∏–π: <span>${state.totalPresses}</span><br>
      –£–≥–∞–¥–∞–Ω–æ –∞–ª–≥–æ—Ä–∏—Ç–º–æ–º: <span>${correctN} –∏–∑ ${scored} (${pct.toFixed(0)}%)</span><br>
      –°–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ 0/1: <span>${count0}/${count1}</span><br>
      –ú–∞–∫—Å. —Å–µ—Ä–∏—è: <span>${maxRun}</span><br>
      –ß–∞—Å—Ç—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω (3): <span>${topTrigram} (&times;${topTriCount})</span>
    </div>
    <div class="pattern-map-container fade-item" style="animation-delay:300ms">
      <div class="pattern-map-label">–ù–∞–∂–∞—Ç–∏—è</div>
      <div class="pattern-map">${pressMap}</div>
      <div class="pattern-map-label" style="margin-top:0.4rem">–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è (–∫—Ä–∞—Å–Ω—ã–π=–≤–µ—Ä–Ω–æ, –∑–µ–ª—ë–Ω—ã–π=–Ω–µ–≤–µ—Ä–Ω–æ)</div>
      <div class="pattern-map">${predMap}</div>
    </div>
    ${levelUpHTML}
    <div class="result-buttons fade-item" style="animation-delay:400ms">
      ${buttonsHTML}
      <button class="btn-secondary" id="btnTheory">–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?</button>
    </div>
  `;

  document.getElementById('btnRetry').addEventListener('click', () => startGame(state.level));
  if (document.getElementById('btnNextLevel')) {
    document.getElementById('btnNextLevel').addEventListener('click', () => startGame(state.level + 1));
  }
  document.getElementById('btnTheory').addEventListener('click', showTheory);

  // Send stats to Google Sheets
  sendStats({
    sessionId: getSessionId(),
    level: lvl.id,
    totalPresses: state.totalPresses,
    correctPredictions: correctN,
    accuracy: +pct.toFixed(1),
    balance: state.balance,
    won: won,
    reason: state.gameOverReason,
    ratio01: count0 + '/' + count1,
    maxRun: maxRun,
    topTrigram: topTrigram + '(x' + topTriCount + ')',
    sequence: state.presses.join(''),
    userAgent: navigator.userAgent,
  });

  showScreen('result');
}

// ===== THEORY =====
function showTheory() {
  const theoryEl = document.getElementById('theory');
  theoryEl.innerHTML = `
    <div class="theory-header">
      <h2>–ö–∞–∫ —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç?</h2>
      <button class="btn-back" id="btnBackResult">‚Üê –ù–∞–∑–∞–¥</button>
    </div>
    <div class="theory-tabs">
      <button class="theory-tab active" data-tab="simple">–ü—Ä–æ—Å—Ç–æ üü¢</button>
      <button class="theory-tab" data-tab="detailed">–ü–æ–¥—Ä–æ–±–Ω–µ–µ üü°</button>
      <button class="theory-tab" data-tab="hardcore">–•–∞—Ä–¥–∫–æ—Ä üî¥</button>
    </div>
    <div id="theoryBody" class="theory-content"></div>
    <button class="btn-primary theory-play-again" id="btnTheoryRetry">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
  `;

  const tabs = theoryEl.querySelectorAll('.theory-tab');
  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      tabs.forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      renderTheoryTab(tab.dataset.tab);
    });
  });

  document.getElementById('btnBackResult').addEventListener('click', () => showScreen('result'));
  document.getElementById('btnTheoryRetry').addEventListener('click', () => startGame(state.level));

  renderTheoryTab('simple');
  showScreen('theory');
}

function renderTheoryTab(tab) {
  const body = document.getElementById('theoryBody');

  if (tab === 'simple') {
    body.innerHTML = `
      <p><strong>–ü–æ–ø—Ä–æ–±—É–π –ø–æ–¥–±—Ä–æ—Å–∏—Ç—å –º–æ–Ω–µ—Ç–∫—É –≤ –≥–æ–ª–æ–≤–µ.</strong> –û—Ä—ë–ª, —Ä–µ—à–∫–∞, –æ—Ä—ë–ª, —Ä–µ—à–∫–∞... –°–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, —Ç—ã —á–µ—Ä–µ–¥—É–µ—à—å. –ù–æ –Ω–∞—Å—Ç–æ—è—â–∞—è –º–æ–Ω–µ—Ç–∫–∞ —Ç–∞–∫ –Ω–µ –¥–µ–ª–∞–µ—Ç ‚Äî –µ–π –Ω–æ—Ä–º–∞–ª—å–Ω–æ –≤—ã–¥–∞—Ç—å 5 –æ—Ä–ª–æ–≤ –ø–æ–¥—Ä—è–¥.</p>
      <p>–≠—Ç–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è <a href="https://ru.wikipedia.org/wiki/–°–∏—Å—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∞—è_–æ—à–∏–±–∫–∞_–≤—ã–∂–∏–≤—à–µ–≥–æ" target="_blank">–∫–æ–≥–Ω–∏—Ç–∏–≤–Ω–æ–µ –∏—Å–∫–∞–∂–µ–Ω–∏–µ</a>: –º–æ–∑–≥ –ø—É—Ç–∞–µ—Ç ¬´—Å–ª—É—á–∞–π–Ω–æ–µ¬ª —Å ¬´—Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –ø–µ—Ä–µ–º–µ—à–∞–Ω–Ω—ã–º¬ª. –ú—ã <strong>–∏–∑–±–µ–≥–∞–µ–º –ø–æ–≤—Ç–æ—Ä–µ–Ω–∏–π</strong>, –ø–æ—Ç–æ–º—É —á—Ç–æ 00001111 –∫–∞–∂–µ—Ç—Å—è –Ω–∞–º –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–º ‚Äî —Ö–æ—Ç—è –¥–ª—è –º–æ–Ω–µ—Ç–∫–∏ —ç—Ç–æ –∞–±—Å–æ–ª—é—Ç–Ω–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ.</p>
      <div class="example-box">
        <strong>–ü—Ä–∏–º–µ—Ä:</strong> –ü–æ–ø—Ä–æ—Å–∏ –¥—Ä—É–≥–∞ ¬´—Å–ª—É—á–∞–π–Ω–æ¬ª –Ω–∞–∑–≤–∞—Ç—å 20 —Ü–∏—Ñ—Ä –æ—Ç 0 –¥–æ 1. –ü–æ—á—Ç–∏ –Ω–∞–≤–µ—Ä–Ω—è–∫–∞ –æ–Ω –±—É–¥–µ—Ç —á–µ—Ä–µ–¥–æ–≤–∞—Ç—å 0 –∏ 1 —á–∞—â–µ, —á–µ–º –≤ 50% —Å–ª—É—á–∞–µ–≤. –ò–º–µ–Ω–Ω–æ —ç—Ç–æ –∏ –ª–æ–≤–∏—Ç –∞–ª–≥–æ—Ä–∏—Ç–º.
      </div>
      <p><strong>–ö–∞–∫ —Ä–∞–±–æ—Ç–∞–µ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º?</strong> –û–Ω –∑–∞–ø–æ–º–∏–Ω–∞–µ—Ç, —á—Ç–æ —Ç—ã –¥–µ–ª–∞–ª –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–π –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –∏–∑ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –Ω–∞–∂–∞—Ç–∏–π. –ù–∞–ø—Ä–∏–º–µ—Ä: ¬´–ø–æ—Å–ª–µ 0-1-0 —ç—Ç–æ—Ç —á–µ–ª–æ–≤–µ–∫ 4 —Ä–∞–∑–∞ –Ω–∞–∂–∞–ª 1 –∏ —Ç–æ–ª—å–∫–æ 1 —Ä–∞–∑ –Ω–∞–∂–∞–ª 0 ‚Äî –∑–Ω–∞—á–∏—Ç, —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –æ–ø—è—Ç—å –Ω–∞–∂–º—ë—Ç 1¬ª.</p>
      <p>–≠—Ç–æ –∫–∞–∫ –¥—Ä—É–≥, –∫–æ—Ç–æ—Ä—ã–π –ø–æ—Å–ª–µ 10 –ø–∞—Ä—Ç–∏–π –≤ <a href="https://ru.wikipedia.org/wiki/–ö–∞–º–µ–Ω—å,_–Ω–æ–∂–Ω–∏—Ü—ã,_–±—É–º–∞–≥–∞" target="_blank">–∫–∞–º–µ–Ω—å-–Ω–æ–∂–Ω–∏—Ü—ã-–±—É–º–∞–≥—É</a> –∑–Ω–∞–µ—Ç, —á—Ç–æ –ø–æ—Å–ª–µ –¥–≤—É—Ö –∫–∞–º–Ω–µ–π —Ç—ã –≤—Å–µ–≥–¥–∞ –±—Ä–æ—Å–∞–µ—à—å –Ω–æ–∂–Ω–∏—Ü—ã. –¢–æ–ª—å–∫–æ –∞–ª–≥–æ—Ä–∏—Ç–º –∑–∞–ø–æ–º–∏–Ω–∞–µ—Ç <em>–≤—Å–µ</em> —Ç–∞–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ.</p>
      <p>–≠—Ç–æ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º –ø—Ä–∏–¥—É–º–∞–ª <a href="https://en.wikipedia.org/wiki/Scott_Aaronson" target="_blank">–°–∫–æ—Ç—Ç –ê–∞—Ä–æ–Ω—Å–æ–Ω</a>, –ø—Ä–æ—Ñ–µ—Å—Å–æ—Ä –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–∏, –∫–∞–∫ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—é —Ç–æ–≥–æ, —á—Ç–æ –ª—é–¥–∏ –ø–ª–æ—Ö–æ –≥–µ–Ω–µ—Ä–∏—Ä—É—é—Ç —Å–ª—É—á–∞–π–Ω—ã–µ —á–∏—Å–ª–∞.</p>
    `;
  } else if (tab === 'detailed') {
    body.innerHTML = `
      <p><strong>–í –æ—Å–Ω–æ–≤–µ ‚Äî <a href="https://ru.wikipedia.org/wiki/–¶–µ–ø—å_–ú–∞—Ä–∫–æ–≤–∞" target="_blank">–º–∞—Ä–∫–æ–≤—Å–∫–∞—è —Ü–µ–ø—å</a>.</strong> –ê–ª–≥–æ—Ä–∏—Ç–º –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç, —á—Ç–æ —Ç–≤–æ—ë —Å–ª–µ–¥—É—é—â–µ–µ –Ω–∞–∂–∞—Ç–∏–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö. –û–Ω –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ —Å—Ç—Ä–æ–∏—Ç 5 –º–æ–¥–µ–ª–µ–π —Ä–∞–∑–Ω–æ–π –≥–ª—É–±–∏–Ω—ã (–æ—Ç 1 –¥–æ 5 –Ω–∞–∂–∞—Ç–∏–π –Ω–∞–∑–∞–¥) –∏ –∫–æ–º–±–∏–Ω–∏—Ä—É–µ—Ç –∏—Ö –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è.</p>
      <div class="example-box">
        <strong>–ö–∞–∫ —ç—Ç–æ –≤—ã–≥–ª—è–¥–∏—Ç –≤–Ω—É—Ç—Ä–∏:</strong> –î–æ–ø—É—Å—Ç–∏–º, –ø–æ—Å–ª–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ 0-1-0-1-1 —Ç—ã 6 —Ä–∞–∑ –Ω–∞–∂–∏–º–∞–ª 0 –∏ 2 —Ä–∞–∑–∞ –Ω–∞–∂–∏–º–∞–ª 1. –ê–ª–≥–æ—Ä–∏—Ç–º –∑–∞–ø–æ–º–∏–Ω–∞–µ—Ç: ¬´–ø–æ—Å–ª–µ 01011 —Å –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é 75% –±—É–¥–µ—Ç 0¬ª. –¢–∞–∫–∏—Ö –∑–∞–ø–∏—Å–µ–π 32 (–¥–ª—è –≥–ª—É–±–∏–Ω—ã 5) + 16 + 8 + 4 + 2 = 62 –≤—Å–µ–≥–æ.
      </div>
      <p><strong>–ü–æ—á–µ–º—É –Ω–µ—Å–∫–æ–ª—å–∫–æ –º–æ–¥–µ–ª–µ–π?</strong> –ö–æ—Ä–æ—Ç–∫–∏–π –∫–æ–Ω—Ç–µ–∫—Å—Ç (1-2 –Ω–∞–∂–∞—Ç–∏—è) –¥–∞—ë—Ç –≥—Ä—É–±—É—é –æ—Ü–µ–Ω–∫—É, –Ω–æ –±—ã—Å—Ç—Ä–æ –Ω–∞–±–∏—Ä–∞–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É. –î–ª–∏–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç (5 –Ω–∞–∂–∞—Ç–∏–π) —Ç–æ—á–Ω–µ–µ, –Ω–æ –µ–º—É –Ω—É–∂–Ω–æ –±–æ–ª—å—à–µ –¥–∞–Ω–Ω—ã—Ö. –ê–Ω—Å–∞–º–±–ª—å –±–µ—Ä—ë—Ç –ª—É—á—à–µ–µ –æ—Ç –∫–∞–∂–¥–æ–≥–æ.</p>
      <p><strong>–¢—Ä–∏ –ª–æ–≤—É—à–∫–∏, –≤ –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ø–∞–¥–∞—é—Ç –ª—é–¥–∏:</strong></p>
      <ul>
        <li><strong><a href="https://en.wikipedia.org/wiki/Gambler%27s_fallacy" target="_blank">Alternation bias</a></strong> ‚Äî –ø–æ—Å–ª–µ 0 —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç–æ –∂–º—É—Ç 1 –∏ –Ω–∞–æ–±–æ—Ä–æ—Ç, –∫–∞–∫ –±—É–¥—Ç–æ ¬´–ø–æ—Ä–∞ –±—ã —É–∂–µ —Å–º–µ–Ω–∏—Ç—å¬ª</li>
        <li><strong>Run avoidance</strong> ‚Äî —Å–µ—Ä–∏–∏ 000 –∏–ª–∏ 111 –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è —Ä–µ–∂–µ, —á–µ–º –¥–æ–ª–∂–Ω—ã. –ù–∞—Å—Ç–æ—è—â–∞—è –º–æ–Ω–µ—Ç–∫–∞ –¥–∞—ë—Ç —Å–µ—Ä–∏—é –∏–∑ 3+ –ø—Ä–∏–º–µ—Ä–Ω–æ –∫–∞–∂–¥—ã–µ 8 –±—Ä–æ—Å–∫–æ–≤</li>
        <li><strong>–ü–æ–¥—Å–æ–∑–Ω–∞—Ç–µ–ª—å–Ω—ã–µ —Ä–∏—Ç–º—ã</strong> ‚Äî –ø–∞—Ç—Ç–µ—Ä–Ω—ã –≤—Ä–æ–¥–µ 0011-0011 –∏–ª–∏ 010-010, –∫–æ—Ç–æ—Ä—ã–µ —Ç—ã –Ω–µ –∑–∞–º–µ—á–∞–µ—à—å, –Ω–æ –∞–ª–≥–æ—Ä–∏—Ç–º –≤–∏–¥–∏—Ç –º–≥–Ω–æ–≤–µ–Ω–Ω–æ</li>
      </ul>
      <p><strong>–ú–æ–∂–Ω–æ –ª–∏ –æ–±—ã–≥—Ä–∞—Ç—å, –∑–Ω–∞—è –∞–ª–≥–æ—Ä–∏—Ç–º?</strong> –¢–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏ –¥–∞ ‚Äî –Ω—É–∂–Ω–æ –ø–æ–º–Ω–∏—Ç—å —Å–≤–æ–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –Ω–∞–∂–∞—Ç–∏–π, –ø—Ä–µ–¥—Å–∫–∞–∑–∞—Ç—å, —á—Ç–æ –ø—Ä–µ–¥—Å–∫–∞–∂–µ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º, –∏ —Å–¥–µ–ª–∞—Ç—å –Ω–∞–æ–±–æ—Ä–æ—Ç. –ù–æ –ø–æ–ø—ã—Ç–∫–∞ ¬´–¥—É–º–∞—Ç—å –Ω–∞–æ–±–æ—Ä–æ—Ç¬ª —Å–∞–º–∞ —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω. –ü–æ —Å—É—Ç–∏, –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–ø–æ—Å–æ–± –≤—ã–∏–≥—Ä–∞—Ç—å ‚Äî –±—ã—Ç—å <a href="https://ru.wikipedia.org/wiki/–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä_—Å–ª—É—á–∞–π–Ω—ã—Ö_—á–∏—Å–µ–ª" target="_blank">–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä–æ–º —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª</a>, –∞ –ª—é–¥–∏ –¥–ª—è —ç—Ç–æ–≥–æ –Ω–µ –ø—Ä–∏—Å–ø–æ—Å–æ–±–ª–µ–Ω—ã.</p>
      <p><strong>–ù–∞ –¥–ª–∏–Ω–Ω–æ–π –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏ –≤—ã–∏–≥—Ä–∞—Ç—å –µ—â—ë —Å–ª–æ–∂–Ω–µ–µ.</strong> –ù–∞ 100 –Ω–∞–∂–∞—Ç–∏—è—Ö –ø–æ–≤–µ–∑—Ç–∏ –º–æ–∂–µ—Ç. –ù–∞ 500 ‚Äî –∞–ª–≥–æ—Ä–∏—Ç–º –Ω–∞–∫–æ–ø–∏–ª –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –ø–æ –∫–∞–∂–¥–æ–º—É –∫–æ–Ω—Ç–µ–∫—Å—Ç—É, –∏ —Å–ª—É—á–∞–π–Ω—ã–µ —Ñ–ª—É–∫—Ç—É–∞—Ü–∏–∏ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞—é—Ç—Å—è. –≠—Ç–æ <a href="https://ru.wikipedia.org/wiki/–ó–∞–∫–æ–Ω_–±–æ–ª—å—à–∏—Ö_—á–∏—Å–µ–ª" target="_blank">–∑–∞–∫–æ–Ω –±–æ–ª—å—à–∏—Ö —á–∏—Å–µ–ª</a> –≤ –¥–µ–π—Å—Ç–≤–∏–∏.</p>
    `;
  } else {
    body.innerHTML = `
      <p><strong>–§–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è.</strong> –≠—Ç–æ <a href="https://en.wikipedia.org/wiki/Prediction_by_partial_matching" target="_blank">Prediction by Partial Matching (PPM)</a> ‚Äî –∞–Ω—Å–∞–º–±–ª—å –∞–¥–∞–ø—Ç–∏–≤–Ω—ã—Ö –º–∞—Ä–∫–æ–≤—Å–∫–∏—Ö –º–æ–¥–µ–ª–µ–π –ø–æ—Ä—è–¥–∫–æ–≤ 1..k:</p>
      <div class="formula">
        x‚ÇÅ, x‚ÇÇ, ..., x‚Çô ‚àà {0, 1}<br><br>
        –î–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ k ‚àà {1,...,5}:<br>
        &nbsp;&nbsp;–∫–æ–Ω—Ç–µ–∫—Å—Ç s = (x‚Çô‚Çã‚Çñ‚Çä‚ÇÅ, ..., x‚Çô)<br>
        &nbsp;&nbsp;—Å—á—ë—Ç—á–∏–∫–∏ C_k(s, 0), C_k(s, 1)<br><br>
        –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ: –≤–∑–≤–µ—à–µ–Ω–Ω–æ–µ –≥–æ–ª–æ—Å–æ–≤–∞–Ω–∏–µ<br>
        &nbsp;&nbsp;score += (pÃÇ‚ÇÅ ‚àí pÃÇ‚ÇÄ) ¬∑ ‚àötotal ¬∑ (1 + k/2)<br>
        &nbsp;&nbsp;–≥–¥–µ pÃÇ_b = (C_k(s,b) + 1) / (total + 2)
      </div>
      <p><a href="https://ru.wikipedia.org/wiki/–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ_–õ–∞–ø–ª–∞—Å–∞" target="_blank">–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –õ–∞–ø–ª–∞—Å–∞</a> (+1 / +2) ‚Äî —ç—Ç–æ –±–∞–π–µ—Å–æ–≤—Å–∫–∏–π prior Beta(1,1), –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å –∏ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç —Ä–∞–∑—É–º–Ω—É—é –æ—Ü–µ–Ω–∫—É –ø—Ä–∏ –º–∞–ª–æ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ –Ω–∞–±–ª—é–¥–µ–Ω–∏–π.</p>

      <p><strong><a href="https://ru.wikipedia.org/wiki/–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–∞—è_—ç–Ω—Ç—Ä–æ–ø–∏—è" target="_blank">–¢–µ–æ—Ä–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏</a>.</strong> –ò—Å—Ç–∏–Ω–Ω–æ —Å–ª—É—á–∞–π–Ω–∞—è –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏–º–µ–µ—Ç —ç–Ω—Ç—Ä–æ–ø–∏—é 1 –±–∏—Ç/—Å–∏–º–≤–æ–ª. –ß–µ–ª–æ–≤–µ—á–µ—Å–∫–∞—è ‚Äî –æ–∫–æ–ª–æ 0.7&ndash;0.9 –±–∏—Ç/—Å–∏–º–≤–æ–ª. –†–∞–∑–Ω–∏—Ü–∞ ‚Äî —ç—Ç–æ –∏–º–µ–Ω–Ω–æ —Ç–æ, —á—Ç–æ —ç–∫—Å–ø–ª—É–∞—Ç–∏—Ä—É–µ—Ç –∞–ª–≥–æ—Ä–∏—Ç–º:</p>
      <div class="formula">
        H = ‚àíŒ£ p(s,b) log‚ÇÇ p(s,b)<br><br>
        –ú–æ–Ω–µ—Ç–∫–∞: H = 1.0 –±–∏—Ç/—Å–∏–º–≤–æ–ª<br>
        –ß–µ–ª–æ–≤–µ–∫: H &asymp; 0.7&ndash;0.9 –±–∏—Ç/—Å–∏–º–≤–æ–ª<br>
        –î–µ—Ñ–∏—Ü–∏—Ç &asymp; 0.1&ndash;0.3 –±–∏—Ç–∞ = –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –∞–ª–≥–æ—Ä–∏—Ç–º–∞
      </div>

      <p><strong>–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã</strong> –ø–æ–º–∏–º–æ –º–∞—Ä–∫–æ–≤—Å–∫–∏—Ö —Ç–∞–±–ª–∏—Ü:</p>
      <ul>
        <li><strong>Global bias</strong> ‚Äî –æ–±—â–∏–π –ø–µ—Ä–µ–∫–æ—Å –∫ 0 –∏–ª–∏ 1 (—É –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ –ª—é–¥–µ–π –µ—Å—Ç—å –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞)</li>
        <li><strong>Alternation rate</strong> ‚Äî —á–∞—Å—Ç–æ—Ç–∞ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–π. –£ —Å–ª—É—á–∞–π–Ω–æ–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ &asymp;50%, —É –ª—é–¥–µ–π –æ–±—ã—á–Ω–æ 55&ndash;70%</li>
        <li><strong>Recent momentum</strong> ‚Äî —Å–∫–æ–ª—å–∑—è—â–µ–µ –æ–∫–Ω–æ 10 –Ω–∞–∂–∞—Ç–∏–π, –ª–æ–≤–∏—Ç —Å–º–µ–Ω—É —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏</li>
      </ul>

      <p><strong><a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv_complexity" target="_blank">Lempel-Ziv —Å–ª–æ–∂–Ω–æ—Å—Ç—å</a>.</strong> –î–ª—è —Å–ª—É—á–∞–π–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ –¥–ª–∏–Ω—ã n: LZ &asymp; n / log‚ÇÇ(n). –ß–µ–ª–æ–≤–µ—á–µ—Å–∫–∏–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏–º–µ—é—Ç –∑–Ω–∞—á–∏–º–æ –±–æ–ª–µ–µ –Ω–∏–∑–∫—É—é LZ-—Å–ª–æ–∂–Ω–æ—Å—Ç—å ‚Äî –∏—Ö –º–æ–∂–Ω–æ —Å–∂–∞—Ç—å, –∞ –∑–Ω–∞—á–∏—Ç, –ø—Ä–µ–¥—Å–∫–∞–∑–∞—Ç—å.</p>

      <p><strong>–ü–æ—á–µ–º—É –Ω–µ –Ω–µ–π—Ä–æ—Å–µ—Ç—å?</strong> –ü—Ä–∏ 100&ndash;500 –Ω–∞–∂–∞—Ç–∏—è—Ö –∏ 62 –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞—Ö ‚Äî –≤ —Å—Ä–µ–¥–Ω–µ–º 1&ndash;8 –Ω–∞–±–ª—é–¥–µ–Ω–∏–π –Ω–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç. –ù–µ–π—Ä–æ—Å–µ—Ç—å <a href="https://ru.wikipedia.org/wiki/–ü–µ—Ä–µ–æ–±—É—á–µ–Ω–∏–µ" target="_blank">–ø–µ—Ä–µ–æ–±—É—á–∏—Ç—Å—è</a>. –ß–∞—Å—Ç–æ—Ç–Ω—ã–π –ø—Ä–µ–¥–∏–∫—Ç–æ—Ä —Å –±–∞–π–µ—Å–æ–≤—Å–∫–∏–º —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ–º ‚Äî –æ–ø—Ç–∏–º–∞–ª–µ–Ω –¥–ª—è –º–∞–ª—ã—Ö –≤—ã–±–æ—Ä–æ–∫.</p>

      <p><strong>–ò—Å—Ç–æ–∫–∏.</strong> –ê–ª–≥–æ—Ä–∏—Ç–º –æ—Å–Ω–æ–≤–∞–Ω –Ω–∞ <a href="https://en.wikipedia.org/wiki/Scott_Aaronson" target="_blank">Oracle</a> –°–∫–æ—Ç—Ç–∞ –ê–∞—Ä–æ–Ω—Å–æ–Ω–∞. –ò–¥–µ—è –≤–æ—Å—Ö–æ–¥–∏—Ç –∫ —Ä–∞–±–æ—Ç–∞–º <a href="https://ru.wikipedia.org/wiki/–®–µ–Ω–Ω–æ–Ω,_–ö–ª–æ–¥" target="_blank">–ö–ª–æ–¥–∞ –®–µ–Ω–Ω–æ–Ω–∞</a> 1950-—Ö –≥–æ–¥–æ–≤ –æ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–∏ —Ç–µ–∫—Å—Ç–∞ –∏ —á–µ–ª–æ–≤–µ—á–µ—Å–∫–æ–π —ç–Ω—Ç—Ä–æ–ø–∏–∏.</p>
    `;
  }
}

// ===== START GAME =====
function startGame(levelIndex) {
  if (levelIndex === undefined) levelIndex = 0;
  state.level = levelIndex;
  const lvl = LEVELS[state.level];
  state.balance = lvl.balance;
  state.initialBalance = lvl.balance;
  state.presses = [];
  state.predictions = [];
  state.correct = [];
  state.totalPresses = 0;
  state.correctPredictions = 0;
  state.gameOver = false;
  state.gameOverReason = '';
  state.lastPressTime = 0;
  initTable();
  updateWater();
  updateHUD();
  document.getElementById('hudAccuracy').textContent = '–ê–ª–≥–æ—Ä–∏—Ç–º: ‚Äî';
  document.getElementById('hudPredResult').className = 'hud-prediction-result';
  document.getElementById('hudPredResult').textContent = '';
  showScreen('game');
}

// ===== EVENT LISTENERS =====
document.getElementById('btnStart').addEventListener('click', () => startGame(0));

document.getElementById('game').addEventListener('pointerdown', (e) => {
  if (state.screen !== 'game' || state.gameOver) return;
  if (e.target.closest('.btn-stop')) return;

  const rect = document.getElementById('game').getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  const choice = e.clientX < window.innerWidth / 2 ? 0 : 1;

  handlePress(choice, x, y);
});

document.getElementById('btnStop').addEventListener('click', () => {
  const lvl = LEVELS[state.level];
  if (state.totalPresses >= lvl.stopMin && !state.gameOver) {
    state.gameOver = true;
    state.gameOverReason = 'manual';
    showResult();
  }
});

// Lock orientation where supported
try {
  if (screen.orientation && screen.orientation.lock) {
    screen.orientation.lock('portrait').catch(() => {});
  }
} catch(e) {}
</script>
</body>
</html>
