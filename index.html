<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, interactive-widget=resizes-content">
<meta name="theme-color" content="#0a0a0a">
<title>Ты не случаен</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  width: 100%; height: 100dvh; overflow: hidden;
  background: #0a0a0a; color: #e0e0e0;
  font-family: 'JetBrains Mono', monospace;
  -webkit-tap-highlight-color: transparent;
  overscroll-behavior: none;
}
body { padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }

#app { width: 100%; height: 100%; position: relative; }

.screen {
  position: absolute; inset: 0;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  opacity: 0; pointer-events: none; transition: opacity 200ms ease;
}
.screen.active { opacity: 1; pointer-events: auto; }

/* ===== WELCOME ===== */
#welcome { padding: 2rem; text-align: center; gap: 1.5rem; }
#welcome h1 { font-size: 2.4rem; font-weight: 700; color: #fff; letter-spacing: -0.03em; line-height: 1.1; }
#welcome .subtitle { font-size: 1rem; color: #00ff88; font-weight: 700; }
#welcome .rules {
  font-size: 1rem; color: #ccc; line-height: 2; max-width: 340px;
}
#welcome .rules strong { color: #fff; }
#welcome .rules .lose { color: #ff2244; font-weight: 700; }
#welcome .rules .win { color: #00ff88; font-weight: 700; }
#welcome .desc-small { font-size: 0.75rem; color: #555; line-height: 1.6; max-width: 300px; }

.btn-start {
  background: #00ff88; color: #0a0a0a; border: none;
  padding: 1.1rem 3.5rem; font-family: 'JetBrains Mono', monospace;
  font-size: 1.15rem; font-weight: 700; border-radius: 10px; cursor: pointer;
  animation: pulse-glow 2s ease-in-out infinite; transition: transform 100ms ease;
}
.btn-start:active { transform: scale(0.96); }

@keyframes pulse-glow {
  0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.3); }
  50% { box-shadow: 0 0 40px rgba(0, 255, 136, 0.6); }
}

.welcome-footer {
  font-size: 0.65rem; color: #333;
}
.welcome-footer a { color: #444; text-decoration: none; border-bottom: 1px solid #333; }
.welcome-footer a:hover { color: #888; }

/* ===== GAME ===== */
#game { user-select: none; touch-action: manipulation; cursor: pointer; }

.water-bg {
  position: absolute; bottom: 0; left: 0; right: 0; height: 100%;
  background: rgba(0, 255, 136, 0.15);
  transition: height 300ms ease-out, background-color 500ms ease;
  pointer-events: none; z-index: 0;
}
.game-divider {
  position: absolute; top: 0; bottom: 0; left: 50%; width: 1px;
  background: rgba(255,255,255,0.08); z-index: 1; pointer-events: none;
}
.zone-label {
  position: absolute; top: 50%; transform: translateY(-50%);
  font-size: 1.5rem; color: rgba(255,255,255,0.06); z-index: 1; pointer-events: none;
}
.zone-label.left { left: calc(25% - 0.5em); }
.zone-label.right { right: calc(25% - 0.5em); }

.game-hud {
  position: absolute; top: 0; left: 0; right: 0; z-index: 2; pointer-events: none;
  display: flex; flex-direction: column; align-items: center; padding-top: 3rem; gap: 0.25rem;
}
.hud-level { font-size: 0.7rem; color: #555; letter-spacing: 0.05em; }
.hud-balance { font-size: 2.5rem; font-weight: 700; color: #e0e0e0; }
.hud-prediction-result {
  font-size: 1.5rem; opacity: 0; transition: opacity 150ms ease;
  height: 2rem; display: flex; align-items: center; justify-content: center;
}
.hud-prediction-result.correct { color: #ff2244; }
.hud-prediction-result.wrong { color: #00ff88; }
.hud-prediction-result.show { opacity: 1; }

.hud-bottom {
  position: absolute; bottom: 1.5rem; left: 0; right: 0;
  text-align: center; z-index: 2; pointer-events: none;
  font-size: 1rem; font-weight: 700; color: #555;
}

.btn-stop {
  position: absolute; top: 1rem; right: 1rem; z-index: 3;
  background: transparent; border: 1px solid rgba(255,255,255,0.15);
  color: rgba(255,255,255,0.3); font-family: 'JetBrains Mono', monospace;
  font-size: 0.7rem; padding: 0.4rem 0.8rem; border-radius: 4px;
  cursor: pointer; transition: opacity 200ms;
}
.btn-stop:disabled { opacity: 0; pointer-events: none; }
.btn-stop:hover:not(:disabled) { color: rgba(255,255,255,0.6); border-color: rgba(255,255,255,0.3); }

.ripple {
  position: absolute; border-radius: 50%; background: rgba(255,255,255,0.15);
  transform: scale(0); animation: ripple-anim 400ms ease-out forwards;
  pointer-events: none; z-index: 1;
}
@keyframes ripple-anim { to { transform: scale(1); opacity: 0; } }

/* ===== RESULT ===== */
#result {
  padding: 2rem 1.5rem; text-align: center; overflow-y: auto;
  justify-content: flex-start; padding-top: 3rem; gap: 1rem;
}
#result h2 { font-size: 1.4rem; font-weight: 700; line-height: 1.3; }
.result-balance { font-size: 2.2rem; font-weight: 700; }

.result-stats { width: 100%; max-width: 340px; text-align: left; font-size: 0.8rem; color: #999; line-height: 1.8; }
.result-stats span { color: #e0e0e0; }

.balance-graph-container { width: 100%; max-width: 340px; }
.balance-graph-label { font-size: 0.7rem; color: #555; text-align: left; margin-bottom: 0.3rem; }
.balance-graph {
  width: 100%; height: 80px; border-radius: 6px; overflow: hidden;
  background: #111; border: 1px solid #222;
}

.pattern-map-container { width: 100%; max-width: 340px; display: flex; flex-direction: column; gap: 0.3rem; }
.pattern-map-label { font-size: 0.7rem; color: #555; text-align: left; }
.pattern-map { display: flex; flex-wrap: wrap; gap: 1px; }
.pattern-map .cell { width: 6px; height: 6px; border-radius: 1px; }

.result-buttons { display: flex; flex-direction: column; gap: 0.75rem; width: 100%; max-width: 280px; margin-top: 0.5rem; }

.btn-primary {
  background: #00ff88; color: #0a0a0a; border: none; padding: 0.9rem 2rem;
  font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 700;
  border-radius: 8px; cursor: pointer; transition: transform 100ms;
}
.btn-primary:active { transform: scale(0.96); }
.btn-secondary {
  background: transparent; color: #999; border: 1px solid #333; padding: 0.8rem 2rem;
  font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; border-radius: 8px;
  cursor: pointer; transition: transform 100ms;
}
.btn-secondary:active { transform: scale(0.96); }

/* ===== THEORY (single scroll) ===== */
#theory {
  padding: 1.5rem; padding-bottom: 3rem; overflow-y: auto;
  justify-content: flex-start; align-items: stretch; gap: 0;
}
.theory-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem; }
.theory-header h2 { font-size: 1.3rem; font-weight: 700; }
.btn-back {
  background: transparent; border: 1px solid #333; color: #999;
  font-family: 'JetBrains Mono', monospace; font-size: 0.75rem;
  padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer;
}

.theory-body { font-size: 0.88rem; line-height: 1.7; color: #ccc; }
.theory-body p { margin-bottom: 1rem; }
.theory-body strong { color: #e0e0e0; }
.theory-body a { color: #00ff88; text-decoration: none; border-bottom: 1px solid rgba(0,255,136,0.3); transition: border-color 150ms; }
.theory-body a:hover { border-color: #00ff88; }
.theory-body ul { padding-left: 1.2rem; margin-bottom: 1rem; }
.theory-body li { margin-bottom: 0.4rem; }

.theory-body .formula {
  background: #111; border: 1px solid #222; border-radius: 6px;
  padding: 0.8rem 1rem; margin: 0.8rem 0; font-size: 0.8rem; color: #aaa; overflow-x: auto;
}
.theory-body .example-box {
  background: #111; border-left: 3px solid #00ff88; padding: 0.8rem 1rem;
  margin: 0.8rem 0; font-size: 0.82rem; color: #bbb; line-height: 1.6;
}
.theory-body .example-box strong { color: #00ff88; }

.theory-divider {
  border: none; border-top: 1px solid #222; margin: 1.5rem 0;
}
.theory-section-title {
  font-size: 1rem; font-weight: 700; color: #e0e0e0; margin-bottom: 1rem;
}
.theory-play-btn { align-self: center; margin: 1.5rem 0; }

.author-link {
  margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #1a1a1a;
  text-align: center; font-size: 0.7rem; color: #444;
}
.author-link a { color: #555; text-decoration: none; border-bottom: 1px solid #333; }
.author-link a:hover { color: #888; }

/* ===== LEVEL BADGE ===== */
.level-badge {
  display: inline-block; padding: 0.2rem 0.6rem; border-radius: 4px;
  font-size: 0.7rem; font-weight: 700; letter-spacing: 0.05em;
}
.level-badge.l1 { border: 1px solid #00ff88; color: #00ff88; }
.level-badge.l2 { border: 1px solid #ffcc00; color: #ffcc00; }
.level-badge.l3 { border: 1px solid #ff2244; color: #ff2244; }

.result-level-up {
  background: rgba(0,255,136,0.08); border: 1px solid rgba(0,255,136,0.3);
  border-radius: 8px; padding: 1rem; text-align: center; width: 100%; max-width: 340px;
}
.result-level-up .level-up-title { font-size: 1rem; font-weight: 700; color: #00ff88; margin-bottom: 0.3rem; }
.result-level-up .level-up-desc { font-size: 0.75rem; color: #999; }

.btn-next-level {
  background: #ffcc00; color: #0a0a0a; border: none; padding: 0.9rem 2rem;
  font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 700;
  border-radius: 8px; cursor: pointer; transition: transform 100ms;
}
.btn-next-level:active { transform: scale(0.96); }
.btn-next-level.final { background: #ff2244; color: #fff; }

.fade-item { opacity: 0; transform: translateY(10px); animation: fade-up 300ms ease forwards; }
@keyframes fade-up { to { opacity: 1; transform: translateY(0); } }

.btn-lang {
  position: absolute; top: 1rem; right: 1rem; z-index: 10;
  background: transparent; border: 1px solid #555; color: #888;
  font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; font-weight: 700;
  padding: 0.35rem 0.7rem; border-radius: 4px; cursor: pointer;
  letter-spacing: 0.05em;
  animation: lang-pulse 2s ease-in-out infinite;
}
.btn-lang:hover { color: #fff; border-color: #888; }
@keyframes lang-pulse {
  0%, 100% { border-color: #555; color: #888; }
  50% { border-color: #00ff88; color: #00ff88; }
}
</style>
</head>
<body>
<div id="app">

  <!-- WELCOME -->
  <div id="welcome" class="screen active">
    <button class="btn-lang" id="btnLang">EN</button>
    <h1 id="welTitle"></h1>
    <p class="subtitle" id="welSubtitle"></p>
    <div class="rules" id="welRules"></div>
    <button class="btn-start" id="btnStart"></button>
    <p class="desc-small" id="welHint"></p>
    <div class="welcome-footer" id="welFooter"></div>
  </div>

  <!-- GAME -->
  <div id="game" class="screen">
    <div class="water-bg" id="waterBg"></div>
    <div class="game-divider"></div>
    <div class="zone-label left">0</div>
    <div class="zone-label right">1</div>
    <div class="game-hud">
      <div class="hud-level" id="hudLevel"></div>
      <div class="hud-balance" id="hudBalance">$15.00</div>
      <div class="hud-prediction-result" id="hudPredResult"></div>
    </div>
    <div class="hud-bottom" id="hudCounter">0/50</div>
    <button class="btn-stop" id="btnStop" disabled></button>
  </div>

  <!-- RESULT -->
  <div id="result" class="screen"></div>

  <!-- THEORY -->
  <div id="theory" class="screen"></div>

</div>

<script>
'use strict';

// ===== i18n =====
const LANG = {
  ru: {
    title: 'Ты не случаен',
    subtitle: 'Попробуй обыграть алгоритм',
    rulesHTML: 'Нажимай <strong>лево</strong> и <strong>право</strong> в случайном порядке.<br>Алгоритм предсказывает каждое нажатие.<br><br>Угадал \u2014 <span class="lose">ты теряешь $1</span><br>Не угадал \u2014 <span class="win">ты получаешь $1.10</span>',
    play: 'Играть',
    stop: 'Стоп',
    hint: 'На компьютере: стрелки \u2190 \u2192',
    level: 'УРОВЕНЬ',
    levelName: 'Уровень',
    won: 'Ты обыграл алгоритм!',
    predictable70: 'Ты полностью предсказуем',
    predictable60: 'Алгоритм читает тебя',
    almost55: 'Почти, но не случайно',
    impressive50: 'Впечатляюще!',
    incredible: 'Невероятно!',
    guessed: 'Угадано',
    of: 'из',
    leftRight: 'Лево/право',
    graphLabel: 'Как менялся баланс',
    yourPresses: 'Твои нажатия',
    predictions: 'Предсказания алгоритма',
    retry: 'Ещё раз',
    replayLevel: 'Переиграть',
    howItWorks: 'Как это работает?',
    unlocked: 'Открыт',
    pressesWord: 'нажатий',
    atStart: 'на старте',
    allLevels: 'Все уровни пройдены!',
    allLevelsDesc: 'Ты прошёл все три уровня.',
    theoryTitle: 'Как это работает?',
    back: 'Назад',
    playAgain: 'Играть снова',
    author: 'Демонстрация',
    // theory
    t1title: 'Шаг за шагом',
    t1p1: 'Алгоритм записывает каждое нажатие. После 10 нажатий: <strong>Л П Л Л П Л П П Л П</strong>. Он ищет в этой записи закономерности.',
    t1ex1: '<strong>Пример.</strong> Ты три раза нажал «лево-право» и каждый раз потом нажал «лево». Алгоритм запомнил. Следующий раз после «лево-право» \u2014 он ставит на «лево».',
    t1p2: 'Для каждой комбинации последних нажатий алгоритм считает: сколько раз после неё было «лево», сколько «право». Чем больше данных \u2014 тем точнее.',
    t1p3: 'Одновременно работают <strong>несколько моделей разной глубины</strong>. На уровне 1 \u2014 до 3 нажатий назад. На уровне 2 \u2014 до 5. На уровне 3 \u2014 до 8. Все голосуют, побеждает большинство.',
    t1p4: '<strong>Память между уровнями.</strong> Алгоритм не сбрасывается. Всё, что он узнал о тебе на первом уровне, он использует на втором и третьем. Чем дольше играешь \u2014 тем лучше он тебя знает.',
    t1p5: '<strong>Экономика.</strong> За промах алгоритм платит $1.10, за угадывание забирает $1. Если бы ты был идеально случайным \u2014 ты бы зарабатывал. Но алгоритм угадывает больше 50%, и этого хватает.',
    t2title: 'Почему ты проигрываешь',
    t2p1: 'Люди путают случайность с чередованием. «Лево-право-лево-право» кажется случайным, но настоящая случайность \u2014 это когда бывает 4\u20135 одинаковых подряд.',
    t2li1: '<strong><a href="https://en.wikipedia.org/wiki/Gambler%27s_fallacy" target="_blank">Заблуждение игрока</a></strong> \u2014 после трёх «лево» кажется, что пора нажать «право». Монетке всё равно.',
    t2li2: '<strong>Страх серий</strong> \u2014 4 подряд кажутся неслучайными. Но при 100 бросках серия 4+ почти гарантирована.',
    t2li3: '<strong>Ритмы</strong> \u2014 лево-лево-право-право. Ты не замечаешь, алгоритм видит.',
    t2random: '<strong>«А может алгоритм просто угадывает случайно?»</strong> Нет. Если бы он ставил наугад, ты бы выигрывал \u2014 экономика в твою пользу ($1.10 против $1). Если ты проигрываешь \u2014 значит, он угадывает чаще 52%. А это возможно только если твои нажатия предсказуемы.',
    t2p2: '<strong>Длинная дистанция.</strong> На 50 нажатиях можно повезти. К 120-му алгоритм уже знает твои привычки. <a href="https://ru.wikipedia.org/wiki/Закон_больших_чисел" target="_blank">Закон больших чисел</a>.',
    t2p3: 'Идею придумал <a href="https://en.wikipedia.org/wiki/Scott_Aaronson" target="_blank">Скотт Ааронсон</a>: мозг \u2014 плохой генератор случайных чисел. Те же алгоритмы работают в сжатии данных (ZIP): предсказуемое = сжимаемое.',
    t3title: 'Математика',
    t3p1: '<a href="https://en.wikipedia.org/wiki/Prediction_by_partial_matching" target="_blank">Prediction by Partial Matching</a> \u2014 ансамбль <a href="https://ru.wikipedia.org/wiki/Цепь_Маркова" target="_blank">марковских моделей</a>:',
    t3formula: 'Контекст s = последние k нажатий<br>C(s, 0) и C(s, 1) \u2014 счётчики<br><br>P(1|s) = (C(s,1) + 1) / (C(s,0) + C(s,1) + 2)<br><small><a href="https://ru.wikipedia.org/wiki/Сглаживание_Лапласа" target="_blank">Лаплас</a>: приор Beta(1,1)</small><br><br>score += (P(1|s) \u2212 P(0|s)) \u00b7 \u221atotal \u00b7 (1 + k/2)',
    t3p2: 'Плюс: глобальный bias, тенденция к чередованию, momentum последних 10 нажатий.',
    t3p3: '<a href="https://ru.wikipedia.org/wiki/Информационная_энтропия" target="_blank">Энтропия</a> случайной последовательности = 1 бит. Человеческая \u2248 0.7\u20130.9 бит. Разница \u2014 преимущество алгоритма.',
    langSwitch: 'EN',
  },
  en: {
    title: 'You\'re Not Random',
    subtitle: 'Try to beat the algorithm',
    rulesHTML: 'Tap <strong>left</strong> and <strong>right</strong> in a random order.<br>The algorithm predicts every tap.<br><br>It\'s right \u2014 <span class="lose">you lose $1</span><br>It\'s wrong \u2014 <span class="win">you earn $1.10</span>',
    play: 'Play',
    stop: 'Stop',
    hint: 'Desktop: arrow keys \u2190 \u2192',
    level: 'LEVEL',
    levelName: 'Level',
    won: 'You beat the algorithm!',
    predictable70: 'Completely predictable',
    predictable60: 'The algorithm reads you',
    almost55: 'Close, but not random',
    impressive50: 'Impressive!',
    incredible: 'Incredible!',
    guessed: 'Guessed',
    of: 'of',
    leftRight: 'Left/right',
    graphLabel: 'Balance over time',
    yourPresses: 'Your taps',
    predictions: 'Algorithm predictions',
    retry: 'Try again',
    replayLevel: 'Replay',
    howItWorks: 'How does it work?',
    unlocked: 'Unlocked',
    pressesWord: 'taps',
    atStart: 'start',
    allLevels: 'All levels completed!',
    allLevelsDesc: 'You beat all three levels.',
    theoryTitle: 'How does it work?',
    back: 'Back',
    playAgain: 'Play again',
    author: 'Demo by',
    t1title: 'Step by step',
    t1p1: 'The algorithm records every tap. After 10: <strong>L R L L R L R R L R</strong>. It searches for patterns.',
    t1ex1: '<strong>Example.</strong> You tapped "left-right" three times and each time followed with "left". The algorithm remembered. Next "left-right" \u2014 it bets "left".',
    t1p2: 'For every combination of recent taps, it counts how often "left" or "right" followed. More data = better predictions.',
    t1p3: '<strong>Multiple models run simultaneously</strong> at different depths. Level 1: up to 3 taps back. Level 2: up to 5. Level 3: up to 8. They all vote.',
    t1p4: '<strong>Memory across levels.</strong> The algorithm doesn\'t reset. Everything it learned about you on level 1 carries into levels 2 and 3. The longer you play, the better it knows you.',
    t1p5: '<strong>Economy.</strong> The algorithm pays $1.10 for each miss and takes $1 for each correct guess. If you were perfectly random, you\'d profit. But it guesses right more than 50%, and that\'s enough.',
    t2title: 'Why you lose',
    t2p1: 'Humans confuse randomness with alternation. "Left-right-left-right" feels random, but real randomness includes 4\u20135 identical in a row.',
    t2li1: '<strong><a href="https://en.wikipedia.org/wiki/Gambler%27s_fallacy" target="_blank">Gambler\'s fallacy</a></strong> \u2014 after three "lefts" it feels like time for "right". A coin doesn\'t care.',
    t2li2: '<strong>Streak avoidance</strong> \u2014 4 in a row feels non-random. But in 100 flips, a streak of 4+ is almost guaranteed.',
    t2li3: '<strong>Rhythms</strong> \u2014 left-left-right-right. You don\'t notice, the algorithm does.',
    t2random: '<strong>"But isn\'t the algorithm just guessing randomly?"</strong> No. If it guessed randomly, you\'d win \u2014 the economy favors you ($1.10 vs $1). If you\'re losing, it means it\'s guessing right more than 52% of the time. That\'s only possible if your taps are predictable.',
    t2p2: '<strong>Long run.</strong> In 50 taps you can get lucky. By tap 120, the algorithm knows your habits. <a href="https://en.wikipedia.org/wiki/Law_of_large_numbers" target="_blank">Law of large numbers</a>.',
    t2p3: 'The idea comes from <a href="https://en.wikipedia.org/wiki/Scott_Aaronson" target="_blank">Scott Aaronson</a>: the brain is a bad random number generator. Same algorithms power data compression (ZIP): predictable = compressible.',
    t3title: 'The math',
    t3p1: '<a href="https://en.wikipedia.org/wiki/Prediction_by_partial_matching" target="_blank">Prediction by Partial Matching</a> \u2014 an ensemble of <a href="https://en.wikipedia.org/wiki/Markov_chain" target="_blank">Markov models</a>:',
    t3formula: 'Context s = last k taps<br>C(s, 0) and C(s, 1) \u2014 counters<br><br>P(1|s) = (C(s,1) + 1) / (C(s,0) + C(s,1) + 2)<br><small><a href="https://en.wikipedia.org/wiki/Additive_smoothing" target="_blank">Laplace</a>: prior Beta(1,1)</small><br><br>score += (P(1|s) \u2212 P(0|s)) \u00b7 \u221atotal \u00b7 (1 + k/2)',
    t3p2: 'Plus: global bias, alternation tendency, momentum of last 10 taps.',
    t3p3: '<a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)" target="_blank">Entropy</a> of random sequence = 1 bit. Human \u2248 0.7\u20130.9 bits. The gap is the algorithm\'s edge.',
    langSwitch: 'RU',
  },
};

let currentLang = 'ru';
function T_get() { return LANG[currentLang]; }
Object.defineProperty(window, 'T', { get: T_get });

// ===== LEVELS =====
const LEVELS = [
  { id: 1, presses: 50,  balance: 15, reward: 1.10, maxK: 3, css: 'l1', stopMin: 15 },
  { id: 2, presses: 80,  balance: 15, reward: 1.10, maxK: 5, css: 'l2', stopMin: 25 },
  { id: 3, presses: 120, balance: 15, reward: 1.10, maxK: 8, css: 'l3', stopMin: 40 },
];

// ===== STATE =====
const state = {
  screen: 'welcome',
  level: 0,
  maxUnlocked: 0,
  balance: 15.00,
  initialBalance: 15.00,
  balanceHistory: [],
  presses: [],
  predictions: [],
  correct: [],
  table: {},
  currentMaxK: 3,
  totalPresses: 0,
  correctPredictions: 0,
  gameOver: false,
  gameOverReason: '',
  lastPressTime: 0,
};

const MIN_INTERVAL = 20;
const WARMUP = 3;

// ===== SCREENS =====
function showScreen(name) {
  state.screen = name;
  document.querySelectorAll('.screen').forEach(s => s.classList.toggle('active', s.id === name));
}

// ===== INIT / EXPAND TABLE =====
function initTable(maxK) {
  state.table = {};
  state.currentMaxK = maxK;
  for (let k = 1; k <= maxK; k++) {
    for (let i = 0; i < (1 << k); i++) {
      state.table[i.toString(2).padStart(k, '0')] = { 0: 0, 1: 0 };
    }
  }
}

function expandTable(newMaxK) {
  for (let k = state.currentMaxK + 1; k <= newMaxK; k++) {
    for (let i = 0; i < (1 << k); i++) {
      const key = i.toString(2).padStart(k, '0');
      if (!state.table[key]) state.table[key] = { 0: 0, 1: 0 };
    }
  }
  state.currentMaxK = newMaxK;
}

// ===== PREDICTION (ensemble) =====
function predict() {
  const n = state.presses.length;
  if (n < 1) return Math.random() < 0.5 ? 0 : 1;
  const maxK = state.currentMaxK;
  let score = 0;

  for (let k = 1; k <= maxK; k++) {
    if (n < k) continue;
    const entry = state.table[state.presses.slice(-k).join('')];
    if (!entry) continue;
    const total = entry[0] + entry[1];
    if (total === 0) continue;
    const p1 = (entry[1] + 1) / (total + 2);
    const p0 = (entry[0] + 1) / (total + 2);
    score += (p1 - p0) * Math.sqrt(total) * (1 + k * 0.5);
  }

  if (n >= 3) {
    const total1 = state.presses.reduce((a, b) => a + b, 0);
    score += ((total1 + 1) / (n + 2) - 0.5);
  }

  if (n >= 5) {
    let sw = 0;
    for (let i = 1; i < n; i++) if (state.presses[i] !== state.presses[i-1]) sw++;
    const alt = (sw / (n - 1) - 0.5) * 3;
    score += state.presses[n-1] === 1 ? -alt : alt;
  }

  if (n >= 6) {
    const w = Math.min(10, n);
    const recent = state.presses.slice(-w);
    let rsw = 0;
    for (let i = 1; i < recent.length; i++) if (recent[i] !== recent[i-1]) rsw++;
    const ralt = (rsw / (recent.length - 1) - 0.5) * 2;
    score += state.presses[n-1] === 1 ? -ralt : ralt;
  }

  if (score > 0) return 1;
  if (score < 0) return 0;
  return Math.random() < 0.5 ? 0 : 1;
}

function updateTable(actual) {
  const n = state.presses.length;
  for (let k = 1; k <= state.currentMaxK; k++) {
    if (n < k + 1) continue;
    const ctx = state.presses.slice(-(k+1), -1).join('');
    if (state.table[ctx]) state.table[ctx][actual]++;
  }
}

// ===== WATER =====
function updateWater() {
  const ratio = Math.max(0, Math.min(2, state.balance / state.initialBalance));
  const el = document.getElementById('waterBg');
  el.style.height = (Math.min(ratio, 1) * 100) + '%';
  const hue = Math.max(0, Math.min(150, ratio * 75));
  el.style.background = 'hsla(' + hue + ', 80%, 50%, 0.15)';
}

// ===== HUD =====
function updateHUD() {
  const lvl = LEVELS[state.level];
  document.getElementById('hudLevel').innerHTML = '<span class="level-badge ' + lvl.css + '">' + T.level + ' ' + lvl.id + '</span>';
  document.getElementById('hudBalance').textContent = '$' + state.balance.toFixed(2);
  document.getElementById('hudCounter').textContent = state.totalPresses + '/' + lvl.presses;
  document.getElementById('btnStop').disabled = state.totalPresses < lvl.stopMin;
}

function flashResult(wasCorrect) {
  const el = document.getElementById('hudPredResult');
  el.textContent = wasCorrect ? '\u2717' : '\u2713';
  el.className = 'hud-prediction-result show ' + (wasCorrect ? 'correct' : 'wrong');
  setTimeout(() => el.classList.remove('show'), 500);
}

// ===== RIPPLE & VIBRATE =====
function createRipple(x, y) {
  const r = document.createElement('div');
  r.className = 'ripple';
  r.style.cssText = 'width:80px;height:80px;left:' + (x-40) + 'px;top:' + (y-40) + 'px';
  document.getElementById('game').appendChild(r);
  setTimeout(() => r.remove(), 400);
}

// ===== GAME PRESS =====
let activePointerId = null;

function handlePress(choice, x, y, pointerId) {
  if (state.gameOver) return;
  if (activePointerId !== null && activePointerId !== pointerId) return;
  const now = Date.now();
  if (now - state.lastPressTime < MIN_INTERVAL) return;
  state.lastPressTime = now;

  createRipple(x, y);
  if (navigator.vibrate) navigator.vibrate(10);

  const prediction = predict();
  state.presses.push(choice);
  state.totalPresses++;
  updateTable(choice);

  if (state.totalPresses > WARMUP) {
    const hit = prediction === choice;
    state.predictions.push(prediction);
    state.correct.push(hit);
    if (hit) { state.correctPredictions++; state.balance -= 1.00; }
    else { state.balance += LEVELS[state.level].reward; }
    state.balance = Math.round(state.balance * 100) / 100;
    state.balanceHistory.push(state.balance);
    flashResult(hit);
  }

  updateWater();
  updateHUD();

  const limit = LEVELS[state.level].presses;
  if (state.totalPresses >= limit) {
    state.gameOver = true; state.gameOverReason = 'limit';
    setTimeout(showResult, 400);
  }
}

// ===== ANALYTICS =====
const SHEETS_URL = 'https://script.google.com/macros/s/AKfycbyUfEUxzWtkLG6-q4nEob-4ORS7OQTzkhQdHsX6dM9i1H5OA_NwVOKgjhKwNG2srpiz4A/exec';

function getSessionId() {
  let id = localStorage.getItem('tns_session');
  if (!id) {
    id = crypto.randomUUID ? crypto.randomUUID() :
      'xxxx-xxxx-xxxx'.replace(/x/g, () => (Math.random()*16|0).toString(16));
    localStorage.setItem('tns_session', id);
  }
  return id;
}

function sendStats(d) {
  if (SHEETS_URL === 'PLACEHOLDER') return;
  try { fetch(SHEETS_URL, { method:'POST', mode:'no-cors', headers:{'Content-Type':'application/json'}, body:JSON.stringify(d) }).catch(()=>{}); } catch(e){}
}

// ===== BALANCE GRAPH (canvas) =====
function drawBalanceGraph(canvas, history, initial) {
  const ctx = canvas.getContext('2d');
  const W = canvas.width = canvas.offsetWidth * 2;
  const H = canvas.height = canvas.offsetHeight * 2;
  ctx.scale(2, 2);
  const w = W / 2, h = H / 2;

  const all = [initial, ...history];
  const maxB = Math.max(...all, initial * 1.3);
  const minB = Math.min(...all, initial * 0.3);
  const range = maxB - minB || 1;

  function yOf(v) { return h - ((v - minB) / range) * (h - 8) - 4; }
  function xOf(i) { return (i / (all.length - 1)) * w; }

  ctx.strokeStyle = '#333';
  ctx.lineWidth = 0.5;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(0, yOf(initial));
  ctx.lineTo(w, yOf(initial));
  ctx.stroke();
  ctx.setLineDash([]);

  for (let i = 1; i < all.length; i++) {
    const x0 = xOf(i - 1), y0 = yOf(all[i - 1]);
    const x1 = xOf(i), y1 = yOf(all[i]);
    const above = (all[i - 1] + all[i]) / 2 >= initial;

    const yBase = yOf(initial);
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.lineTo(x1, yBase);
    ctx.lineTo(x0, yBase);
    ctx.closePath();
    ctx.fillStyle = above ? 'rgba(0,255,136,0.15)' : 'rgba(255,34,68,0.12)';
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.strokeStyle = above ? '#00ff88' : '#ff2244';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }
}

// ===== RESULT =====
function showResult() {
  const lvl = LEVELS[state.level];
  const scored = state.correct.length;
  const correctN = state.correctPredictions;
  const pct = scored > 0 ? (correctN / scored * 100) : 0;
  const won = state.balance >= state.initialBalance;
  const hasNext = state.level < LEVELS.length - 1;

  let title = '';
  if (won) title = T.won;
  else if (pct >= 70) title = T.predictable70;
  else if (pct >= 60) title = T.predictable60;
  else if (pct >= 55) title = T.almost55;
  else if (pct >= 50) title = T.impressive50;
  else title = T.incredible;

  if (won && hasNext && state.level + 1 > state.maxUnlocked) state.maxUnlocked = state.level + 1;

  const count0 = state.presses.filter(p => p === 0).length;
  const count1 = state.presses.length - count0;

  const balColor = state.balance >= state.initialBalance ? '#00ff88' : '#ff2244';

  const cellSize = state.presses.length > 200 ? 4 : 6;
  const cs = ';width:' + cellSize + 'px;height:' + cellSize + 'px';

  let pressMap = '';
  state.presses.forEach(p => {
    pressMap += '<div class="cell" style="background:' + (p===0?'#333':'#aaa') + cs + '"></div>';
  });
  let predMap = '';
  const warmup = state.presses.length - state.correct.length;
  for (let i = 0; i < warmup; i++) predMap += '<div class="cell" style="background:#1a1a1a' + cs + '"></div>';
  state.correct.forEach(c => {
    predMap += '<div class="cell" style="background:' + (c?'#ff2244':'#00ff88') + cs + '"></div>';
  });

  let levelUpHTML = '';
  if (won && hasNext) {
    const nx = LEVELS[state.level + 1];
    levelUpHTML = '<div class="result-level-up fade-item" style="animation-delay:350ms"><div class="level-up-title">' + T.unlocked + ' ' + T.levelName + ' ' + nx.id + '!</div><div class="level-up-desc">' + nx.presses + ' ' + T.pressesWord + ', $' + nx.balance + ' ' + T.atStart + '</div></div>';
  } else if (won && !hasNext) {
    levelUpHTML = '<div class="result-level-up fade-item" style="animation-delay:350ms"><div class="level-up-title" style="color:#ff2244">' + T.allLevels + '</div><div class="level-up-desc">' + T.allLevelsDesc + '</div></div>';
  }

  let btns = '';
  if (won && hasNext) {
    const nx = LEVELS[state.level + 1];
    btns = '<button class="btn-next-level' + (nx.id===3?' final':'') + '" id="btnNextLevel">' + T.levelName + ' ' + nx.id + ' &rarr;</button><button class="btn-secondary" id="btnRetry">' + T.replayLevel + '</button>';
  } else {
    btns = '<button class="btn-primary" id="btnRetry">' + T.retry + '</button>';
  }

  document.getElementById('result').innerHTML =
    '<span class="level-badge ' + lvl.css + ' fade-item" style="animation-delay:0ms">' + T.level + ' ' + lvl.id + '</span>' +
    '<h2 class="fade-item" style="animation-delay:50ms">' + title + '</h2>' +
    '<div class="result-balance fade-item" style="animation-delay:100ms;color:' + balColor + '">$' + state.balance.toFixed(2) + '</div>' +
    '<div class="result-stats fade-item" style="animation-delay:150ms">' +
      T.guessed + ': <span>' + correctN + ' ' + T.of + ' ' + scored + ' (' + pct.toFixed(0) + '%)</span><br>' +
      T.leftRight + ': <span>' + count0 + '/' + count1 + '</span>' +
    '</div>' +
    '<div class="balance-graph-container fade-item" style="animation-delay:200ms">' +
      '<div class="balance-graph-label">' + T.graphLabel + '</div>' +
      '<canvas class="balance-graph" id="balGraph"></canvas>' +
    '</div>' +
    '<div class="pattern-map-container fade-item" style="animation-delay:280ms">' +
      '<div class="pattern-map-label">' + T.yourPresses + '</div>' +
      '<div class="pattern-map">' + pressMap + '</div>' +
      '<div class="pattern-map-label" style="margin-top:0.4rem">' + T.predictions + '</div>' +
      '<div class="pattern-map">' + predMap + '</div>' +
    '</div>' +
    levelUpHTML +
    '<div class="result-buttons fade-item" style="animation-delay:380ms">' + btns +
      '<button class="btn-secondary" id="btnTheory">' + T.howItWorks + '</button>' +
    '</div>';

  document.getElementById('btnRetry').addEventListener('click', () => startGame(state.level));
  const nextBtn = document.getElementById('btnNextLevel');
  if (nextBtn) nextBtn.addEventListener('click', () => startGame(state.level + 1));
  document.getElementById('btnTheory').addEventListener('click', showTheory);

  showScreen('result');

  requestAnimationFrame(() => {
    const canvas = document.getElementById('balGraph');
    if (canvas && state.balanceHistory.length > 1) drawBalanceGraph(canvas, state.balanceHistory, state.initialBalance);
  });

  sendStats({
    sessionId: getSessionId(), level: lvl.id,
    totalPresses: state.totalPresses, correctPredictions: correctN,
    accuracy: +pct.toFixed(1), balance: state.balance, won: won,
    reason: state.gameOverReason, ratio01: count0+'/'+count1,
    maxRun: 0, topTrigram: '',
    sequence: state.presses.join(''), userAgent: navigator.userAgent,
  });
}

// ===== THEORY =====
function showTheory() {
  document.getElementById('theory').innerHTML =
    '<div class="theory-header"><h2>' + T.theoryTitle + '</h2><button class="btn-back" id="btnBackResult">&larr; ' + T.back + '</button></div>' +
    '<div class="theory-body" id="theoryBody">' +

    '<p class="theory-section-title">' + T.t1title + '</p>' +
    '<p>' + T.t1p1 + '</p>' +
    '<div class="example-box">' + T.t1ex1 + '</div>' +
    '<p>' + T.t1p2 + '</p>' +
    '<p>' + T.t1p3 + '</p>' +
    '<p>' + T.t1p4 + '</p>' +
    '<p>' + T.t1p5 + '</p>' +

    '<div style="text-align:center"><button class="btn-primary theory-play-btn" id="btnPlay1">' + T.playAgain + '</button></div>' +

    '<hr class="theory-divider">' +
    '<p class="theory-section-title">' + T.t2title + '</p>' +
    '<p>' + T.t2p1 + '</p>' +
    '<ul>' +
    '<li>' + T.t2li1 + '</li>' +
    '<li>' + T.t2li2 + '</li>' +
    '<li>' + T.t2li3 + '</li>' +
    '</ul>' +
    '<div class="example-box">' + T.t2random + '</div>' +
    '<p>' + T.t2p2 + '</p>' +
    '<p>' + T.t2p3 + '</p>' +

    '<hr class="theory-divider">' +
    '<p class="theory-section-title">' + T.t3title + '</p>' +
    '<p>' + T.t3p1 + '</p>' +
    '<div class="formula">' + T.t3formula + '</div>' +
    '<p>' + T.t3p2 + '</p>' +
    '<p>' + T.t3p3 + '</p>' +

    '<div style="text-align:center"><button class="btn-primary theory-play-btn" id="btnPlay2">' + T.playAgain + '</button></div>' +

    '<div class="author-link">' + T.author + ': <a href="https://www.facebook.com/teo.spiro.2025" target="_blank">Teo Spiro</a></div>' +
    '</div>';

  document.getElementById('btnBackResult').addEventListener('click', () => showScreen('result'));
  document.getElementById('btnPlay1').addEventListener('click', () => startGame(state.level));
  document.getElementById('btnPlay2').addEventListener('click', () => startGame(state.level));

  showScreen('theory');
}

// ===== START GAME =====
function startGame(levelIndex) {
  const prevLevel = state.level;
  state.level = levelIndex || 0;
  const lvl = LEVELS[state.level];

  // Carryover: if advancing to next level, expand table; otherwise reset
  if (levelIndex > prevLevel && levelIndex > 0 && state.presses.length > 0) {
    expandTable(lvl.maxK);
  } else {
    state.presses = [];
    initTable(lvl.maxK);
  }

  state.balance = lvl.balance;
  state.initialBalance = lvl.balance;
  state.balanceHistory = [lvl.balance];
  state.predictions = [];
  state.correct = [];
  state.totalPresses = 0;
  state.correctPredictions = 0;
  state.gameOver = false;
  state.gameOverReason = '';
  state.lastPressTime = 0;
  updateWater();
  updateHUD();
  document.getElementById('hudPredResult').className = 'hud-prediction-result';
  document.getElementById('hudPredResult').textContent = '';
  showScreen('game');
}

// ===== EVENTS =====
document.getElementById('btnStart').addEventListener('click', () => startGame(0));

document.getElementById('game').addEventListener('pointerdown', (e) => {
  if (state.screen !== 'game' || state.gameOver) return;
  if (e.target.closest('.btn-stop')) return;
  activePointerId = e.pointerId;
  const rect = document.getElementById('game').getBoundingClientRect();
  handlePress(e.clientX < window.innerWidth / 2 ? 0 : 1, e.clientX - rect.left, e.clientY - rect.top, e.pointerId);
});

document.getElementById('game').addEventListener('pointerup', (e) => {
  if (e.pointerId === activePointerId) activePointerId = null;
});
document.getElementById('game').addEventListener('pointercancel', (e) => {
  if (e.pointerId === activePointerId) activePointerId = null;
});

document.getElementById('btnStop').addEventListener('click', () => {
  const lvl = LEVELS[state.level];
  if (state.totalPresses >= lvl.stopMin && !state.gameOver) {
    state.gameOver = true; state.gameOverReason = 'manual'; showResult();
  }
});

// ===== KEYBOARD (arrows) =====
document.addEventListener('keydown', (e) => {
  if (state.screen !== 'game' || state.gameOver) return;
  let choice = -1;
  if (e.key === 'ArrowLeft') choice = 0;
  else if (e.key === 'ArrowRight') choice = 1;
  if (choice < 0) return;
  e.preventDefault();
  const cx = choice === 0 ? window.innerWidth * 0.25 : window.innerWidth * 0.75;
  const cy = window.innerHeight * 0.5;
  handlePress(choice, cx, cy, 'keyboard');
});

// ===== LANGUAGE =====
function updateAllText() {
  document.getElementById('welTitle').textContent = T.title;
  document.getElementById('welSubtitle').textContent = T.subtitle;
  document.getElementById('welRules').innerHTML = T.rulesHTML;
  document.getElementById('btnStart').textContent = T.play;
  document.getElementById('btnLang').textContent = T.langSwitch;
  document.getElementById('btnStop').textContent = T.stop;
  document.getElementById('welHint').textContent = T.hint;
  document.getElementById('welFooter').innerHTML = '<a href="https://www.facebook.com/teo.spiro.2025" target="_blank">Teo Spiro</a>';
  document.title = T.title;
}
updateAllText();

document.getElementById('btnLang').addEventListener('click', () => {
  currentLang = currentLang === 'ru' ? 'en' : 'ru';
  updateAllText();
});

try { if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); } catch(e){}
</script>
</body>
</html>
