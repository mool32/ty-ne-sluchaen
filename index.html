<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, interactive-widget=resizes-content">
<meta name="theme-color" content="#0a0a0a">
<title>Ты не случаен</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  width: 100%; height: 100dvh; overflow: hidden;
  background: #0a0a0a; color: #e0e0e0;
  font-family: 'JetBrains Mono', monospace;
  -webkit-tap-highlight-color: transparent;
  overscroll-behavior: none;
}
body { padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }

#app { width: 100%; height: 100%; position: relative; }

.screen {
  position: absolute; inset: 0;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  opacity: 0; pointer-events: none; transition: opacity 200ms ease;
}
.screen.active { opacity: 1; pointer-events: auto; }

/* ===== WELCOME ===== */
#welcome { padding: 2rem; text-align: center; gap: 2rem; }
#welcome h1 { font-size: 2.4rem; font-weight: 700; color: #fff; letter-spacing: -0.03em; line-height: 1.1; }
#welcome .subtitle { font-size: 1rem; color: #00ff88; font-weight: 700; }
#welcome .desc { font-size: 0.85rem; color: #888; line-height: 1.7; max-width: 320px; }
#welcome .desc strong { color: #e0e0e0; }

.btn-start {
  background: #00ff88; color: #0a0a0a; border: none;
  padding: 1.1rem 3.5rem; font-family: 'JetBrains Mono', monospace;
  font-size: 1.15rem; font-weight: 700; border-radius: 10px; cursor: pointer;
  animation: pulse-glow 2s ease-in-out infinite; transition: transform 100ms ease;
}
.btn-start:active { transform: scale(0.96); }

@keyframes pulse-glow {
  0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.3); }
  50% { box-shadow: 0 0 40px rgba(0, 255, 136, 0.6); }
}

/* ===== GAME ===== */
#game { user-select: none; touch-action: manipulation; cursor: pointer; }

.water-bg {
  position: absolute; bottom: 0; left: 0; right: 0; height: 100%;
  background: rgba(0, 255, 136, 0.15);
  transition: height 300ms ease-out, background-color 500ms ease;
  pointer-events: none; z-index: 0;
}
.game-divider {
  position: absolute; top: 0; bottom: 0; left: 50%; width: 1px;
  background: rgba(255,255,255,0.08); z-index: 1; pointer-events: none;
}
.zone-label {
  position: absolute; top: 50%; transform: translateY(-50%);
  font-size: 1.5rem; color: rgba(255,255,255,0.06); z-index: 1; pointer-events: none;
}
.zone-label.left { left: calc(25% - 0.5em); }
.zone-label.right { right: calc(25% - 0.5em); }

.game-hud {
  position: absolute; top: 0; left: 0; right: 0; z-index: 2; pointer-events: none;
  display: flex; flex-direction: column; align-items: center; padding-top: 3rem; gap: 0.25rem;
}
.hud-level { font-size: 0.7rem; color: #555; letter-spacing: 0.05em; }
.hud-balance { font-size: 2.5rem; font-weight: 700; color: #e0e0e0; }
.hud-prediction-result {
  font-size: 1.5rem; opacity: 0; transition: opacity 150ms ease;
  height: 2rem; display: flex; align-items: center; justify-content: center;
}
.hud-prediction-result.correct { color: #ff2244; }
.hud-prediction-result.wrong { color: #00ff88; }
.hud-prediction-result.show { opacity: 1; }

.hud-bottom {
  position: absolute; bottom: 1.5rem; left: 0; right: 0;
  text-align: center; z-index: 2; pointer-events: none;
  font-size: 1rem; font-weight: 700; color: #555;
}

.btn-stop {
  position: absolute; top: 1rem; right: 1rem; z-index: 3;
  background: transparent; border: 1px solid rgba(255,255,255,0.15);
  color: rgba(255,255,255,0.3); font-family: 'JetBrains Mono', monospace;
  font-size: 0.7rem; padding: 0.4rem 0.8rem; border-radius: 4px;
  cursor: pointer; transition: opacity 200ms;
}
.btn-stop:disabled { opacity: 0; pointer-events: none; }
.btn-stop:hover:not(:disabled) { color: rgba(255,255,255,0.6); border-color: rgba(255,255,255,0.3); }

.ripple {
  position: absolute; border-radius: 50%; background: rgba(255,255,255,0.15);
  transform: scale(0); animation: ripple-anim 400ms ease-out forwards;
  pointer-events: none; z-index: 1;
}
@keyframes ripple-anim { to { transform: scale(1); opacity: 0; } }

/* ===== RESULT ===== */
#result {
  padding: 2rem 1.5rem; text-align: center; overflow-y: auto;
  justify-content: flex-start; padding-top: 3rem; gap: 1rem;
}
#result h2 { font-size: 1.4rem; font-weight: 700; line-height: 1.3; }
.result-balance { font-size: 2.2rem; font-weight: 700; }

.result-stats { width: 100%; max-width: 340px; text-align: left; font-size: 0.8rem; color: #999; line-height: 1.8; }
.result-stats span { color: #e0e0e0; }

.balance-graph-container { width: 100%; max-width: 340px; }
.balance-graph-label { font-size: 0.7rem; color: #555; text-align: left; margin-bottom: 0.3rem; }
.balance-graph {
  width: 100%; height: 80px; border-radius: 6px; overflow: hidden;
  background: #111; border: 1px solid #222;
}

.pattern-map-container { width: 100%; max-width: 340px; display: flex; flex-direction: column; gap: 0.3rem; }
.pattern-map-label { font-size: 0.7rem; color: #555; text-align: left; }
.pattern-map { display: flex; flex-wrap: wrap; gap: 1px; }
.pattern-map .cell { width: 6px; height: 6px; border-radius: 1px; }

.result-buttons { display: flex; flex-direction: column; gap: 0.75rem; width: 100%; max-width: 280px; margin-top: 0.5rem; }

.btn-primary {
  background: #00ff88; color: #0a0a0a; border: none; padding: 0.9rem 2rem;
  font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 700;
  border-radius: 8px; cursor: pointer; transition: transform 100ms;
}
.btn-primary:active { transform: scale(0.96); }
.btn-secondary {
  background: transparent; color: #999; border: 1px solid #333; padding: 0.8rem 2rem;
  font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; border-radius: 8px;
  cursor: pointer; transition: transform 100ms;
}
.btn-secondary:active { transform: scale(0.96); }

/* ===== THEORY (single scroll) ===== */
#theory {
  padding: 1.5rem; padding-bottom: 3rem; overflow-y: auto;
  justify-content: flex-start; align-items: stretch; gap: 0;
}
.theory-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem; }
.theory-header h2 { font-size: 1.3rem; font-weight: 700; }
.btn-back {
  background: transparent; border: 1px solid #333; color: #999;
  font-family: 'JetBrains Mono', monospace; font-size: 0.75rem;
  padding: 0.4rem 0.8rem; border-radius: 4px; cursor: pointer;
}

.theory-body { font-size: 0.88rem; line-height: 1.7; color: #ccc; }
.theory-body p { margin-bottom: 1rem; }
.theory-body strong { color: #e0e0e0; }
.theory-body a { color: #00ff88; text-decoration: none; border-bottom: 1px solid rgba(0,255,136,0.3); transition: border-color 150ms; }
.theory-body a:hover { border-color: #00ff88; }
.theory-body ul { padding-left: 1.2rem; margin-bottom: 1rem; }
.theory-body li { margin-bottom: 0.4rem; }

.theory-body .formula {
  background: #111; border: 1px solid #222; border-radius: 6px;
  padding: 0.8rem 1rem; margin: 0.8rem 0; font-size: 0.8rem; color: #aaa; overflow-x: auto;
}
.theory-body .example-box {
  background: #111; border-left: 3px solid #00ff88; padding: 0.8rem 1rem;
  margin: 0.8rem 0; font-size: 0.82rem; color: #bbb; line-height: 1.6;
}
.theory-body .example-box strong { color: #00ff88; }

.theory-divider {
  border: none; border-top: 1px solid #222; margin: 1.5rem 0;
}
.theory-section-title {
  font-size: 1rem; font-weight: 700; color: #e0e0e0; margin-bottom: 1rem;
}
.theory-play-btn { align-self: center; margin: 1.5rem 0; }

.author-link {
  margin-top: 2rem; padding-top: 1rem; border-top: 1px solid #1a1a1a;
  text-align: center; font-size: 0.7rem; color: #444;
}
.author-link a { color: #555; text-decoration: none; border-bottom: 1px solid #333; }
.author-link a:hover { color: #888; }

/* ===== LEVEL BADGE ===== */
.level-badge {
  display: inline-block; padding: 0.2rem 0.6rem; border-radius: 4px;
  font-size: 0.7rem; font-weight: 700; letter-spacing: 0.05em;
}
.level-badge.l1 { border: 1px solid #00ff88; color: #00ff88; }
.level-badge.l2 { border: 1px solid #ffcc00; color: #ffcc00; }
.level-badge.l3 { border: 1px solid #ff2244; color: #ff2244; }

.result-level-up {
  background: rgba(0,255,136,0.08); border: 1px solid rgba(0,255,136,0.3);
  border-radius: 8px; padding: 1rem; text-align: center; width: 100%; max-width: 340px;
}
.result-level-up .level-up-title { font-size: 1rem; font-weight: 700; color: #00ff88; margin-bottom: 0.3rem; }
.result-level-up .level-up-desc { font-size: 0.75rem; color: #999; }

.btn-next-level {
  background: #ffcc00; color: #0a0a0a; border: none; padding: 0.9rem 2rem;
  font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; font-weight: 700;
  border-radius: 8px; cursor: pointer; transition: transform 100ms;
}
.btn-next-level:active { transform: scale(0.96); }
.btn-next-level.final { background: #ff2244; color: #fff; }

.fade-item { opacity: 0; transform: translateY(10px); animation: fade-up 300ms ease forwards; }
@keyframes fade-up { to { opacity: 1; transform: translateY(0); } }

.btn-lang {
  position: absolute; top: 1rem; right: 1rem; z-index: 10;
  background: transparent; border: 1px solid #333; color: #666;
  font-family: 'JetBrains Mono', monospace; font-size: 0.7rem; font-weight: 700;
  padding: 0.3rem 0.6rem; border-radius: 4px; cursor: pointer;
  letter-spacing: 0.05em;
}
.btn-lang:hover { color: #aaa; border-color: #555; }
</style>
</head>
<body>
<div id="app">

  <!-- WELCOME -->
  <div id="welcome" class="screen active">
    <button class="btn-lang" id="btnLang">EN</button>
    <h1 id="welTitle">Ты не случаен</h1>
    <p class="subtitle" id="welSubtitle">Попробуй обыграть алгоритм</p>
    <p class="desc" id="welDesc"></p>
    <button class="btn-start" id="btnStart">Играть</button>
  </div>

  <!-- GAME -->
  <div id="game" class="screen">
    <div class="water-bg" id="waterBg"></div>
    <div class="game-divider"></div>
    <div class="zone-label left">0</div>
    <div class="zone-label right">1</div>
    <div class="game-hud">
      <div class="hud-level" id="hudLevel"></div>
      <div class="hud-balance" id="hudBalance">$50.00</div>
      <div class="hud-prediction-result" id="hudPredResult"></div>
    </div>
    <div class="hud-bottom" id="hudCounter">0/100</div>
    <button class="btn-stop" id="btnStop" disabled>Стоп</button>
  </div>

  <!-- RESULT -->
  <div id="result" class="screen"></div>

  <!-- THEORY -->
  <div id="theory" class="screen"></div>

</div>

<script>
'use strict';

// ===== i18n =====
const LANG = {
  ru: {
    title: 'Ты не случаен',
    subtitle: 'Попробуй обыграть алгоритм',
    descLine1: 'Нажимай на <strong>правую</strong> и <strong>левую</strong> половины экрана в случайном порядке. Алгоритм будет предсказывать каждое твоё следующее нажатие.',
    descLine2: 'Угадал \u2014 ты теряешь <strong>$1</strong>.<br>Не угадал \u2014 ты получаешь <strong>$1.05</strong>.',
    play: 'Играть',
    stop: 'Стоп',
    // result
    bankrupt: 'Алгоритм забрал всё',
    won: 'Ты обыграл алгоритм!',
    predictable70: 'Ты полностью предсказуем',
    predictable60: 'Алгоритм читает тебя',
    almost55: 'Почти, но не случайно',
    impressive50: 'Впечатляюще!',
    incredible: 'Невероятно!',
    guessed: 'Угадано',
    of: 'из',
    leftRight: 'Лево/право',
    graphLabel: 'Как менялся баланс',
    yourPresses: 'Твои нажатия',
    predictions: 'Предсказания алгоритма',
    retry: 'Ещё раз',
    replayLevel: 'Переиграть',
    howItWorks: 'Как это работает?',
    unlocked: 'Открыт',
    pressesWord: 'нажатий',
    atStart: 'на старте',
    stakes: 'ставки',
    allLevels: 'Все уровни пройдены!',
    allLevelsDesc: '300 нажатий, ставки $1/$1, и ты выстоял.',
    // theory
    theoryTitle: 'Как это работает?',
    back: 'Назад',
    playAgain: 'Играть снова',
    author: 'Демонстрация',
    t1title: 'Шаг за шагом: что делает алгоритм',
    t1p1: 'Представь, что кто-то записывает каждое твоё нажатие. После 10 нажатий запись выглядит так: <strong>Л П Л Л П Л П П Л П</strong>. Алгоритм ищет в этой записи повторяющиеся фрагменты.',
    t1ex1: '<strong>Пример.</strong> Допустим, ты уже три раза нажал «лево-право» и после этого каждый раз нажимал «лево». Алгоритм это запомнил. Когда ты снова нажмёшь «лево-право» \u2014 он поставит на «лево». И скорее всего будет прав.',
    t1p2: 'Алгоритм ведёт таблицу: для каждой комбинации последних нажатий он считает, сколько раз после неё было «лево» и сколько \u2014 «право». Чем больше данных \u2014 тем точнее прогноз.',
    t1p3: 'Но он смотрит не на одну длину. У него <strong>несколько моделей одновременно</strong>: одна помнит 1 нажатие назад, другая \u2014 2, третья \u2014 3, и так далее. На первом уровне глубина до 3, на втором \u2014 до 5, на третьем \u2014 до 8. Все модели «голосуют», и алгоритм выбирает по большинству.',
    t1ex2: '<strong>Почему первые 3 нажатия бесплатные?</strong> Алгоритму нужна минимальная история, чтобы начать предсказывать. Первые 3 нажатия \u2014 разминка: он смотрит, но ещё не ставит.',
    t1p4: '<strong>Экономика.</strong> На уровнях 1\u20132 за промах алгоритма ты получаешь $1.05, а за угадывание теряешь $1. Форы немного \u2014 но алгоритм угадывает чаще, чем промахивается, и этого достаточно. На уровне 3 ставки равны: $1/$1, без форы.',
    t2title: 'Почему ты проигрываешь',
    t2p1: 'Люди думают, что случайность \u2014 это чередование. «Лево-право-лево-право» кажется случайным. Но настоящая случайность другая: в ней бывает 4\u20135 одинаковых подряд, и это нормально.',
    t2li1: '<strong><a href="https://en.wikipedia.org/wiki/Gambler%27s_fallacy" target="_blank">Заблуждение игрока</a></strong> \u2014 после трёх «лево» кажется, что пора нажать «право». Монетке всё равно, что было до этого.',
    t2li2: '<strong>Страх серий</strong> \u2014 4 одинаковых подряд кажутся неслучайными. Но при 100 бросках монетки серия 4+ почти гарантирована.',
    t2li3: '<strong>Подсознательные ритмы</strong> \u2014 лево-лево-право-право, или лево-право-лево. Ты не замечаешь, а алгоритм \u2014 видит.',
    t2p2: '<strong>Длинная дистанция.</strong> На 100 нажатиях алгоритм видел каждую комбинацию 1\u20133 раза \u2014 можно повезти. На 300 у него 5\u201315 наблюдений на каждую, и везение заканчивается. Это <a href="https://ru.wikipedia.org/wiki/Закон_больших_чисел" target="_blank">закон больших чисел</a>.',
    t2p3: 'Идею придумал <a href="https://en.wikipedia.org/wiki/Scott_Aaronson" target="_blank">Скотт Ааронсон</a>, профессор информатики: человеческий мозг \u2014 плохой генератор случайных чисел. Такие же алгоритмы используются в сжатии данных (ZIP). Если последовательность предсказуема \u2014 её можно сжать.',
    t3title: 'Математика',
    t3p1: 'Алгоритм \u2014 это <a href="https://en.wikipedia.org/wiki/Prediction_by_partial_matching" target="_blank">Prediction by Partial Matching</a>: ансамбль <a href="https://ru.wikipedia.org/wiki/Цепь_Маркова" target="_blank">марковских моделей</a> разных порядков. Для каждого порядка k он хранит таблицу контекстов и считает частоты:',
    t3formula: 'Контекст s = последние k нажатий<br>C(s, 0) и C(s, 1) \u2014 счётчики<br><br>P(1|s) = (C(s,1) + 1) / (C(s,0) + C(s,1) + 2)<br><small>(<a href="https://ru.wikipedia.org/wiki/Сглаживание_Лапласа" target="_blank">сглаживание Лапласа</a> \u2014 байесовский приор Beta(1,1))</small><br><br>score += (P(1|s) \u2212 P(0|s)) \u00b7 \u221atotal \u00b7 (1 + k/2)<br><small>Больший k и больше данных = больше вес</small>',
    t3p2: 'Дополнительно: глобальный bias (общая склонность к 0 или 1), тенденция к чередованию, и momentum последних 10 нажатий. Всё суммируется в один score, и алгоритм ставит на знак этого score.',
    t3p3: '<a href="https://ru.wikipedia.org/wiki/Информационная_энтропия" target="_blank">Энтропия</a> случайной последовательности = 1 бит/символ. Человеческая \u2248 0.7\u20130.9 бит. Эта разница \u2014 и есть преимущество алгоритма.',
    langSwitch: 'EN',
  },
  en: {
    title: 'You\'re Not Random',
    subtitle: 'Try to beat the algorithm',
    descLine1: 'Tap the <strong>left</strong> and <strong>right</strong> halves of the screen in a random order. The algorithm will try to predict your every next tap.',
    descLine2: 'It guesses right \u2014 you lose <strong>$1</strong>.<br>It guesses wrong \u2014 you earn <strong>$1.05</strong>.',
    play: 'Play',
    stop: 'Stop',
    bankrupt: 'The algorithm took everything',
    won: 'You beat the algorithm!',
    predictable70: 'Completely predictable',
    predictable60: 'The algorithm reads you',
    almost55: 'Close, but not random',
    impressive50: 'Impressive!',
    incredible: 'Incredible!',
    guessed: 'Guessed',
    of: 'of',
    leftRight: 'Left/right',
    graphLabel: 'Balance over time',
    yourPresses: 'Your taps',
    predictions: 'Algorithm predictions',
    retry: 'Try again',
    replayLevel: 'Replay',
    howItWorks: 'How does it work?',
    unlocked: 'Unlocked',
    pressesWord: 'taps',
    atStart: 'start',
    stakes: 'stakes',
    allLevels: 'All levels completed!',
    allLevelsDesc: '300 taps, $1/$1 stakes, and you survived.',
    theoryTitle: 'How does it work?',
    back: 'Back',
    playAgain: 'Play again',
    author: 'Demo by',
    t1title: 'Step by step: what the algorithm does',
    t1p1: 'Imagine someone writes down every tap you make. After 10 taps: <strong>L R L L R L R R L R</strong>. The algorithm searches this record for repeating patterns.',
    t1ex1: '<strong>Example.</strong> Say you tapped "left-right" three times and each time followed it with "left". The algorithm remembers this. Next time you tap "left-right" \u2014 it bets on "left". And it\'s probably right.',
    t1p2: 'The algorithm keeps a table: for every combination of recent taps, it counts how often "left" or "right" followed. More data = better predictions.',
    t1p3: 'It doesn\'t look at just one length. It runs <strong>multiple models simultaneously</strong>: one remembers 1 tap back, another 2, another 3, and so on. Level 1 goes up to 3 deep, level 2 up to 5, level 3 up to 8. All models "vote" and the majority wins.',
    t1ex2: '<strong>Why are the first 3 taps free?</strong> The algorithm needs minimal history to start predicting. The first 3 taps are warm-up: it watches, but doesn\'t bet.',
    t1p4: '<strong>Economy.</strong> On levels 1\u20132, you earn $1.05 for each miss and lose $1 for each correct guess. Slight edge for you \u2014 but the algorithm guesses right more than half the time, and that\'s enough. Level 3 is even: $1/$1, no advantage.',
    t2title: 'Why you lose',
    t2p1: 'Humans think randomness means alternating. "Left-right-left-right" feels random. But real randomness includes 4\u20135 identical taps in a row \u2014 and that\'s normal.',
    t2li1: '<strong><a href="https://en.wikipedia.org/wiki/Gambler%27s_fallacy" target="_blank">Gambler\'s fallacy</a></strong> \u2014 after three "lefts" it feels like time for "right". A coin doesn\'t care what came before.',
    t2li2: '<strong>Streak avoidance</strong> \u2014 4 identical in a row feels non-random. But in 100 coin flips, a streak of 4+ is almost guaranteed.',
    t2li3: '<strong>Subconscious rhythms</strong> \u2014 left-left-right-right, or left-right-left. You don\'t notice, but the algorithm does.',
    t2p2: '<strong>Long run.</strong> In 100 taps, the algorithm saw each pattern 1\u20133 times \u2014 you can get lucky. In 300, it has 5\u201315 observations per pattern, and luck runs out. That\'s the <a href="https://en.wikipedia.org/wiki/Law_of_large_numbers" target="_blank">law of large numbers</a>.',
    t2p3: 'The idea comes from <a href="https://en.wikipedia.org/wiki/Scott_Aaronson" target="_blank">Scott Aaronson</a>, a CS professor: the human brain is a bad random number generator. The same algorithms are used in data compression (ZIP). If a sequence is predictable \u2014 it\'s compressible.',
    t3title: 'The math',
    t3p1: 'The algorithm is <a href="https://en.wikipedia.org/wiki/Prediction_by_partial_matching" target="_blank">Prediction by Partial Matching</a>: an ensemble of <a href="https://en.wikipedia.org/wiki/Markov_chain" target="_blank">Markov models</a> of different orders. For each order k, it keeps a context table and counts frequencies:',
    t3formula: 'Context s = last k taps<br>C(s, 0) and C(s, 1) \u2014 counters<br><br>P(1|s) = (C(s,1) + 1) / (C(s,0) + C(s,1) + 2)<br><small>(<a href="https://en.wikipedia.org/wiki/Additive_smoothing" target="_blank">Laplace smoothing</a> \u2014 Bayesian prior Beta(1,1))</small><br><br>score += (P(1|s) \u2212 P(0|s)) \u00b7 \u221atotal \u00b7 (1 + k/2)<br><small>Higher k and more data = more weight</small>',
    t3p2: 'Additional signals: global bias (overall tendency toward 0 or 1), alternation tendency, and momentum of the last 10 taps. Everything sums into one score, and the algorithm bets on the sign.',
    t3p3: '<a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)" target="_blank">Entropy</a> of a random sequence = 1 bit/symbol. Human \u2248 0.7\u20130.9 bits. That gap is the algorithm\'s edge.',
    langSwitch: 'RU',
  },
};

let currentLang = (navigator.language || '').startsWith('en') ? 'en' : 'ru';
function T_get() { return LANG[currentLang]; }
Object.defineProperty(window, 'T', { get: T_get });

// ===== LEVELS =====
const LEVELS = [
  { id: 1, name: 'Уровень 1', presses: 100,  balance: 10, reward: 1.05, maxK: 3, label: 'УРОВЕНЬ 1', css: 'l1', stopMin: 20 },
  { id: 2, name: 'Уровень 2', presses: 200,  balance: 10, reward: 1.05, maxK: 5, label: 'УРОВЕНЬ 2', css: 'l2', stopMin: 50 },
  { id: 3, name: 'Уровень 3', presses: 300,  balance: 20, reward: 1.00, maxK: 8, label: 'УРОВЕНЬ 3', css: 'l3', stopMin: 80 },
];

// ===== STATE =====
const state = {
  screen: 'welcome',
  level: 0,
  maxUnlocked: 0,
  balance: 50.00,
  initialBalance: 50.00,
  balanceHistory: [],
  presses: [],
  predictions: [],
  correct: [],
  table: {},
  totalPresses: 0,
  correctPredictions: 0,
  gameOver: false,
  gameOverReason: '',
  lastPressTime: 0,
};

const MIN_INTERVAL = 40;
const WARMUP = 3;

// ===== SCREENS =====
function showScreen(name) {
  state.screen = name;
  document.querySelectorAll('.screen').forEach(s => s.classList.toggle('active', s.id === name));
}

// ===== INIT TABLE =====
function initTable() {
  const maxK = LEVELS[state.level].maxK;
  state.table = {};
  for (let k = 1; k <= maxK; k++) {
    for (let i = 0; i < (1 << k); i++) {
      state.table[i.toString(2).padStart(k, '0')] = { 0: 0, 1: 0 };
    }
  }
}

// ===== PREDICTION (ensemble) =====
function predict() {
  const n = state.presses.length;
  if (n < 1) return Math.random() < 0.5 ? 0 : 1;
  const maxK = LEVELS[state.level].maxK;
  let score = 0;

  for (let k = 1; k <= maxK; k++) {
    if (n < k) continue;
    const entry = state.table[state.presses.slice(-k).join('')];
    if (!entry) continue;
    const total = entry[0] + entry[1];
    if (total === 0) continue;
    const p1 = (entry[1] + 1) / (total + 2);
    const p0 = (entry[0] + 1) / (total + 2);
    score += (p1 - p0) * Math.sqrt(total) * (1 + k * 0.5);
  }

  if (n >= 3) {
    const total1 = state.presses.reduce((a, b) => a + b, 0);
    score += ((total1 + 1) / (n + 2) - 0.5);
  }

  if (n >= 5) {
    let sw = 0;
    for (let i = 1; i < n; i++) if (state.presses[i] !== state.presses[i-1]) sw++;
    const alt = (sw / (n - 1) - 0.5) * 3;
    score += state.presses[n-1] === 1 ? -alt : alt;
  }

  if (n >= 6) {
    const w = Math.min(10, n);
    const recent = state.presses.slice(-w);
    let rsw = 0;
    for (let i = 1; i < recent.length; i++) if (recent[i] !== recent[i-1]) rsw++;
    const ralt = (rsw / (recent.length - 1) - 0.5) * 2;
    score += state.presses[n-1] === 1 ? -ralt : ralt;
  }

  if (score > 0) return 1;
  if (score < 0) return 0;
  return Math.random() < 0.5 ? 0 : 1;
}

function updateTable(actual) {
  const n = state.presses.length;
  const maxK = LEVELS[state.level].maxK;
  for (let k = 1; k <= maxK; k++) {
    if (n < k + 1) continue;
    const ctx = state.presses.slice(-(k+1), -1).join('');
    if (state.table[ctx]) state.table[ctx][actual]++;
  }
}

// ===== WATER =====
function updateWater() {
  const ratio = Math.max(0, Math.min(2, state.balance / state.initialBalance));
  const el = document.getElementById('waterBg');
  el.style.height = (Math.min(ratio, 1) * 100) + '%';
  const hue = Math.max(0, Math.min(150, ratio * 75));
  el.style.background = 'hsla(' + hue + ', 80%, 50%, 0.15)';
}

// ===== HUD =====
function updateHUD() {
  const lvl = LEVELS[state.level];
  document.getElementById('hudLevel').innerHTML = '<span class="level-badge ' + lvl.css + '">' + lvl.label + '</span>';
  document.getElementById('hudBalance').textContent = '$' + state.balance.toFixed(2);
  document.getElementById('hudCounter').textContent = state.totalPresses + '/' + lvl.presses;
  document.getElementById('btnStop').disabled = state.totalPresses < lvl.stopMin;
}

function flashResult(wasCorrect) {
  const el = document.getElementById('hudPredResult');
  el.textContent = wasCorrect ? '\u2717' : '\u2713';
  el.className = 'hud-prediction-result show ' + (wasCorrect ? 'correct' : 'wrong');
  setTimeout(() => el.classList.remove('show'), 500);
}

// ===== RIPPLE & VIBRATE =====
function createRipple(x, y) {
  const r = document.createElement('div');
  r.className = 'ripple';
  r.style.cssText = 'width:80px;height:80px;left:' + (x-40) + 'px;top:' + (y-40) + 'px';
  document.getElementById('game').appendChild(r);
  setTimeout(() => r.remove(), 400);
}

// ===== GAME PRESS =====
let activePointerId = null;

function handlePress(choice, x, y, pointerId) {
  if (state.gameOver) return;
  // Block multitouch: only one finger at a time
  if (activePointerId !== null && activePointerId !== pointerId) return;
  const now = Date.now();
  if (now - state.lastPressTime < MIN_INTERVAL) return;
  state.lastPressTime = now;

  createRipple(x, y);
  if (navigator.vibrate) navigator.vibrate(10);

  const prediction = predict();
  state.presses.push(choice);
  state.totalPresses++;
  updateTable(choice);

  if (state.totalPresses > WARMUP) {
    const hit = prediction === choice;
    state.predictions.push(prediction);
    state.correct.push(hit);
    if (hit) { state.correctPredictions++; state.balance -= 1.00; }
    else { state.balance += LEVELS[state.level].reward; }
    state.balance = Math.round(state.balance * 100) / 100;
    state.balanceHistory.push(state.balance);
    flashResult(hit);
  }

  updateWater();
  updateHUD();

  const limit = LEVELS[state.level].presses;
  if (state.totalPresses >= limit) {
    state.gameOver = true; state.gameOverReason = 'limit';
    setTimeout(showResult, 400);
  }
}

// ===== ANALYTICS =====
const SHEETS_URL = 'https://script.google.com/macros/s/AKfycbyUfEUxzWtkLG6-q4nEob-4ORS7OQTzkhQdHsX6dM9i1H5OA_NwVOKgjhKwNG2srpiz4A/exec';

function getSessionId() {
  let id = localStorage.getItem('tns_session');
  if (!id) {
    id = crypto.randomUUID ? crypto.randomUUID() :
      'xxxx-xxxx-xxxx'.replace(/x/g, () => (Math.random()*16|0).toString(16));
    localStorage.setItem('tns_session', id);
  }
  return id;
}

function sendStats(d) {
  if (SHEETS_URL === 'PLACEHOLDER') return;
  try { fetch(SHEETS_URL, { method:'POST', mode:'no-cors', headers:{'Content-Type':'application/json'}, body:JSON.stringify(d) }).catch(()=>{}); } catch(e){}
}

// ===== BALANCE GRAPH (canvas) =====
function drawBalanceGraph(canvas, history, initial) {
  const ctx = canvas.getContext('2d');
  const W = canvas.width = canvas.offsetWidth * 2;
  const H = canvas.height = canvas.offsetHeight * 2;
  ctx.scale(2, 2);
  const w = W / 2, h = H / 2;

  const all = [initial, ...history];
  const maxB = Math.max(...all, initial * 1.3);
  const minB = Math.min(...all, initial * 0.5);
  const range = maxB - minB || 1;

  function yOf(v) { return h - ((v - minB) / range) * (h - 8) - 4; }
  function xOf(i) { return (i / (all.length - 1)) * w; }

  // Grid line at initial balance
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 0.5;
  ctx.setLineDash([3, 3]);
  ctx.beginPath();
  ctx.moveTo(0, yOf(initial));
  ctx.lineTo(w, yOf(initial));
  ctx.stroke();
  ctx.setLineDash([]);

  // Segment-by-segment: green above initial, red below
  for (let i = 1; i < all.length; i++) {
    const x0 = xOf(i - 1), y0 = yOf(all[i - 1]);
    const x1 = xOf(i), y1 = yOf(all[i]);
    const above = (all[i - 1] + all[i]) / 2 >= initial;

    // Fill segment to baseline
    const yBase = yOf(initial);
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.lineTo(x1, yBase);
    ctx.lineTo(x0, yBase);
    ctx.closePath();
    ctx.fillStyle = above ? 'rgba(0,255,136,0.15)' : 'rgba(255,34,68,0.12)';
    ctx.fill();

    // Line segment
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.strokeStyle = above ? '#00ff88' : '#ff2244';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }
}

// ===== RESULT =====
function showResult() {
  const lvl = LEVELS[state.level];
  const scored = state.correct.length;
  const correctN = state.correctPredictions;
  const pct = scored > 0 ? (correctN / scored * 100) : 0;
  const won = state.balance >= state.initialBalance;
  const hasNext = state.level < LEVELS.length - 1;

  let title = '';
  if (state.gameOverReason === 'bankrupt') title = T.bankrupt;
  else if (won) title = T.won;
  else if (pct >= 70) title = T.predictable70;
  else if (pct >= 60) title = T.predictable60;
  else if (pct >= 55) title = T.almost55;
  else if (pct >= 50) title = T.impressive50;
  else title = T.incredible;

  if (won && hasNext && state.level + 1 > state.maxUnlocked) state.maxUnlocked = state.level + 1;

  const count0 = state.presses.filter(p => p === 0).length;
  const count1 = state.presses.length - count0;

  const balColor = state.balance >= state.initialBalance ? '#00ff88' : '#ff2244';

  const cellSize = state.presses.length > 200 ? 4 : 6;
  const cs = ';width:' + cellSize + 'px;height:' + cellSize + 'px';

  let pressMap = '';
  state.presses.forEach(p => {
    pressMap += '<div class="cell" style="background:' + (p===0?'#333':'#aaa') + cs + '"></div>';
  });
  let predMap = '';
  const warmup = state.presses.length - state.correct.length;
  for (let i = 0; i < warmup; i++) predMap += '<div class="cell" style="background:#1a1a1a' + cs + '"></div>';
  state.correct.forEach(c => {
    predMap += '<div class="cell" style="background:' + (c?'#ff2244':'#00ff88') + cs + '"></div>';
  });

  let levelUpHTML = '';
  if (won && hasNext) {
    const nx = LEVELS[state.level + 1];
    const rewardDesc = nx.reward === 1.00 ? ', ' + T.stakes + ' $1/$1' : '';
    levelUpHTML = '<div class="result-level-up fade-item" style="animation-delay:350ms"><div class="level-up-title">' + T.unlocked + ' ' + nx.name + '!</div><div class="level-up-desc">' + nx.presses + ' ' + T.pressesWord + ', $' + nx.balance + ' ' + T.atStart + rewardDesc + '</div></div>';
  } else if (won && !hasNext) {
    levelUpHTML = '<div class="result-level-up fade-item" style="animation-delay:350ms"><div class="level-up-title" style="color:#ff2244">' + T.allLevels + '</div><div class="level-up-desc">' + T.allLevelsDesc + '</div></div>';
  }

  let btns = '';
  if (won && hasNext) {
    const nx = LEVELS[state.level + 1];
    btns = '<button class="btn-next-level' + (nx.id===3?' final':'') + '" id="btnNextLevel">' + nx.name + ' &rarr;</button><button class="btn-secondary" id="btnRetry">' + T.replayLevel + '</button>';
  } else {
    btns = '<button class="btn-primary" id="btnRetry">' + T.retry + '</button>';
  }

  document.getElementById('result').innerHTML =
    '<span class="level-badge ' + lvl.css + ' fade-item" style="animation-delay:0ms">' + lvl.label + '</span>' +
    '<h2 class="fade-item" style="animation-delay:50ms">' + title + '</h2>' +
    '<div class="result-balance fade-item" style="animation-delay:100ms;color:' + balColor + '">$' + state.balance.toFixed(2) + '</div>' +
    '<div class="result-stats fade-item" style="animation-delay:150ms">' +
      T.guessed + ': <span>' + correctN + ' ' + T.of + ' ' + scored + ' (' + pct.toFixed(0) + '%)</span><br>' +
      T.leftRight + ': <span>' + count0 + '/' + count1 + '</span>' +
    '</div>' +
    '<div class="balance-graph-container fade-item" style="animation-delay:200ms">' +
      '<div class="balance-graph-label">' + T.graphLabel + '</div>' +
      '<canvas class="balance-graph" id="balGraph"></canvas>' +
    '</div>' +
    '<div class="pattern-map-container fade-item" style="animation-delay:280ms">' +
      '<div class="pattern-map-label">' + T.yourPresses + '</div>' +
      '<div class="pattern-map">' + pressMap + '</div>' +
      '<div class="pattern-map-label" style="margin-top:0.4rem">' + T.predictions + '</div>' +
      '<div class="pattern-map">' + predMap + '</div>' +
    '</div>' +
    levelUpHTML +
    '<div class="result-buttons fade-item" style="animation-delay:380ms">' + btns +
      '<button class="btn-secondary" id="btnTheory">' + T.howItWorks + '</button>' +
    '</div>';

  document.getElementById('btnRetry').addEventListener('click', () => startGame(state.level));
  const nextBtn = document.getElementById('btnNextLevel');
  if (nextBtn) nextBtn.addEventListener('click', () => startGame(state.level + 1));
  document.getElementById('btnTheory').addEventListener('click', showTheory);

  showScreen('result');

  // Draw graph after screen is visible
  requestAnimationFrame(() => {
    const canvas = document.getElementById('balGraph');
    if (canvas && state.balanceHistory.length > 1) drawBalanceGraph(canvas, state.balanceHistory, state.initialBalance);
  });

  sendStats({
    sessionId: getSessionId(), level: lvl.id,
    totalPresses: state.totalPresses, correctPredictions: correctN,
    accuracy: +pct.toFixed(1), balance: state.balance, won: won,
    reason: state.gameOverReason, ratio01: count0+'/'+count1,
    maxRun: 0, topTrigram: '',
    sequence: state.presses.join(''), userAgent: navigator.userAgent,
  });
}

// ===== THEORY (single scroll page) =====
function showTheory() {
  document.getElementById('theory').innerHTML =
    '<div class="theory-header"><h2>' + T.theoryTitle + '</h2><button class="btn-back" id="btnBackResult">&larr; ' + T.back + '</button></div>' +
    '<div class="theory-body" id="theoryBody">' +

    // === PART 1: How it works step by step ===
    '<p class="theory-section-title">' + T.t1title + '</p>' +

    '<p>' + T.t1p1 + '</p>' +

    '<div class="example-box">' + T.t1ex1 + '</div>' +

    '<p>' + T.t1p2 + '</p>' +

    '<p>' + T.t1p3 + '</p>' +

    '<div class="example-box">' + T.t1ex2 + '</div>' +

    '<p>' + T.t1p4 + '</p>' +

    '<div style="text-align:center"><button class="btn-primary theory-play-btn" id="btnPlay1">' + T.playAgain + '</button></div>' +

    // === PART 2: Why you lose ===
    '<hr class="theory-divider">' +
    '<p class="theory-section-title">' + T.t2title + '</p>' +

    '<p>' + T.t2p1 + '</p>' +

    '<ul>' +
    '<li>' + T.t2li1 + '</li>' +
    '<li>' + T.t2li2 + '</li>' +
    '<li>' + T.t2li3 + '</li>' +
    '</ul>' +

    '<p>' + T.t2p2 + '</p>' +

    '<p>' + T.t2p3 + '</p>' +

    // === PART 3: Math ===
    '<hr class="theory-divider">' +
    '<p class="theory-section-title">' + T.t3title + '</p>' +

    '<p>' + T.t3p1 + '</p>' +
    '<div class="formula">' + T.t3formula + '</div>' +

    '<p>' + T.t3p2 + '</p>' +

    '<p>' + T.t3p3 + '</p>' +

    '<div style="text-align:center"><button class="btn-primary theory-play-btn" id="btnPlay2">' + T.playAgain + '</button></div>' +

    '<div class="author-link">' + T.author + ': <a href="https://www.facebook.com/teo.spiro.2025" target="_blank">Teo Spiro</a></div>' +
    '</div>';

  document.getElementById('btnBackResult').addEventListener('click', () => showScreen('result'));
  document.getElementById('btnPlay1').addEventListener('click', () => startGame(state.level));
  document.getElementById('btnPlay2').addEventListener('click', () => startGame(state.level));

  showScreen('theory');
}

// ===== START GAME =====
function startGame(levelIndex) {
  state.level = levelIndex || 0;
  const lvl = LEVELS[state.level];
  state.balance = lvl.balance;
  state.initialBalance = lvl.balance;
  state.balanceHistory = [lvl.balance];
  state.presses = [];
  state.predictions = [];
  state.correct = [];
  state.totalPresses = 0;
  state.correctPredictions = 0;
  state.gameOver = false;
  state.gameOverReason = '';
  state.lastPressTime = 0;
  initTable();
  updateWater();
  updateHUD();
  document.getElementById('hudPredResult').className = 'hud-prediction-result';
  document.getElementById('hudPredResult').textContent = '';
  showScreen('game');
}

// ===== EVENTS =====
document.getElementById('btnStart').addEventListener('click', () => startGame(0));

document.getElementById('game').addEventListener('pointerdown', (e) => {
  if (state.screen !== 'game' || state.gameOver) return;
  if (e.target.closest('.btn-stop')) return;
  activePointerId = e.pointerId;
  const rect = document.getElementById('game').getBoundingClientRect();
  handlePress(e.clientX < window.innerWidth / 2 ? 0 : 1, e.clientX - rect.left, e.clientY - rect.top, e.pointerId);
});

document.getElementById('game').addEventListener('pointerup', (e) => {
  if (e.pointerId === activePointerId) activePointerId = null;
});
document.getElementById('game').addEventListener('pointercancel', (e) => {
  if (e.pointerId === activePointerId) activePointerId = null;
});

document.getElementById('btnStop').addEventListener('click', () => {
  const lvl = LEVELS[state.level];
  if (state.totalPresses >= lvl.stopMin && !state.gameOver) {
    state.gameOver = true; state.gameOverReason = 'manual'; showResult();
  }
});

// ===== KEYBOARD (arrows) =====
document.addEventListener('keydown', (e) => {
  if (state.screen !== 'game' || state.gameOver) return;
  let choice = -1;
  if (e.key === 'ArrowLeft') choice = 0;
  else if (e.key === 'ArrowRight') choice = 1;
  if (choice < 0) return;
  e.preventDefault();
  const cx = choice === 0 ? window.innerWidth * 0.25 : window.innerWidth * 0.75;
  const cy = window.innerHeight * 0.5;
  handlePress(choice, cx, cy, 'keyboard');
});

// ===== LANGUAGE =====
function updateWelcomeText() {
  document.getElementById('welTitle').textContent = T.title;
  document.getElementById('welSubtitle').textContent = T.subtitle;
  document.getElementById('welDesc').innerHTML = T.descLine1 + '<br><br>' + T.descLine2;
  document.getElementById('btnStart').textContent = T.play;
  document.getElementById('btnLang').textContent = T.langSwitch;
  document.getElementById('btnStop').textContent = T.stop;
  document.title = T.title;
}
updateWelcomeText();

document.getElementById('btnLang').addEventListener('click', () => {
  currentLang = currentLang === 'ru' ? 'en' : 'ru';
  updateWelcomeText();
});

try { if (screen.orientation && screen.orientation.lock) screen.orientation.lock('portrait').catch(()=>{}); } catch(e){}
</script>
</body>
</html>
